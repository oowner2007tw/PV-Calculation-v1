<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>太陽光電規劃系統</title>
    
    <!-- 1. 載入外部函式庫 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- FingerprintJS v4 (IIFE build exposes window.FingerprintJS) -->
    <script src="https://openfpcdn.io/fingerprintjs/v4/iife.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: { colors: { brand: { 50: '#f0f9ff', 500: '#0ea5e9', 600: '#0284c7' } } }
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');
        
        body { font-family: "Noto Sans TC", "Microsoft JhengHei", system-ui, sans-serif; background-color: #f8fafc; color: #334155; font-size: 0.9em; }
        
        /* ... (Keep existing non-PDF styles) ... */
        h1, h2, h3, h4, h5, h6 { font-size: revert !important; }
        .text-xl { font-size: 1.25rem !important; }
        .text-2xl { font-size: 1.5rem !important; }
        .text-3xl { font-size: 1.875rem !important; }
        .text-4xl { font-size: 2.25rem !important; }
        .text-5xl { font-size: 3rem !important; }
        
        /* PDF Generation Styles */
        #pdf-staging-area {
            position: fixed; top: 0; left: -10000px;
            width: 210mm;
            background: white;
            z-index: -100;
        }

        .pdf-page {
            width: 210mm;
            height: 297mm;
            position: relative;
            background: white;
            overflow: hidden;
            box-sizing: border-box;
            padding: 0; /* Margins handled by inner content or padding */
        }

        .pdf-header-layer {
            position: absolute; top: 10mm; left: 10mm; right: 10mm;
            height: 15mm;
            border-bottom: 2px solid #cbd5e1;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }

        .pdf-footer-layer {
            position: absolute; bottom: 10mm; left: 10mm; right: 10mm;
            height: 10mm;
            border-top: 1px solid #cbd5e1;
            display: flex; justify-content: space-between; align-items: center;
            font-size: 10px; color: #94a3b8;
        }

        .pdf-body-layer {
            position: absolute;
            top: 30mm; /* 10mm margin + 15mm header + 5mm gap */
            left: 10mm;
            width: 190mm; /* 210 - 20 */
            height: 237mm; /* 297 - 30(top) - 30(bottom) */
            /* border: 1px dashed red; debug */
        }

        /* Report Content Styles */
        .report-doc-title {
            font-size: 24px; font-weight: bold; color: #1e40af;
            letter-spacing: 1px; line-height: 1.2;
        }
        .report-doc-subtitle {
            font-size: 12px; color: #64748b; font-style: italic;
        }
        
        .report-group-title {
            margin-top: 10px; margin-bottom: 15px;
            padding-bottom: 5px;
            color: #1e40af; font-weight: bold; font-size: 16px;
            border-bottom: 2px solid #1e40af;
            break-after: avoid;
        }
        
        .report-item {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px dashed #e2e8f0;
            page-break-inside: avoid;
            break-inside: avoid;
        }
        
        .report-item:last-child { border-bottom: none; }

        /* ... (Keep existing component styles) ... */
        .tab-btn { position: relative; padding: 14px 24px; font-weight: 600; color: #64748b; transition: all 0.2s; cursor: pointer; white-space: nowrap; }
        .tab-btn.active { color: #0284c7; background-color: #f0f9ff; }
        .tab-btn.active::after { content: ''; position: absolute; bottom: 0; left: 0; width: 100%; height: 3px; background-color: #0284c7; }
        .tab-content { display: none; }
        .tab-content.active { display: block; animation: fadeIn 0.4s ease-out; }
        .sld-node { background: linear-gradient(145deg, #ffffff, #fcfcfc); border: 1px solid #e2e8f0; border-left: 4px solid #3b82f6; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05); position: relative; }
        .sld-node:hover { transform: translateY(-3px); box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); z-index: 20; }
        .console-box { background-color: #0f172a; color: #e2e8f0; font-family: 'Consolas', 'Monaco', monospace; border: 1px solid #334155; box-shadow: inset 0 2px 8px rgba(0,0,0,0.5); }
        .calc-block { margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px dashed #334155; }
        .calc-block:last-child { border-bottom: none; }
        .plan-card { background: white; border: 1px solid #e2e8f0; border-radius: 8px; overflow: hidden; margin-bottom: 16px; }
        .plan-header { background: #f8fafc; padding: 12px 16px; border-bottom: 1px solid #e2e8f0; font-weight: bold; color: #1e293b; display: flex; justify-content: space-between; align-items: center; }
        .plan-body { padding: 16px; }
        
        /* Report specific inner styles */
        .report-table { width: 100%; border-collapse: collapse; font-size: 12px; margin: 5px 0; }
        .report-table th, .report-table td { border-bottom: 1px solid #e2e8f0; padding: 6px 8px; text-align: left; }
        .report-table th { background: #f8fafc; font-weight: bold; color: #334155; border-bottom: 2px solid #cbd5e1; }
        
        .report-formula { 
            font-family: 'Cambria Math', 'Cambria', 'Times New Roman', serif; 
            background: transparent; padding: 4px 0; display: block; margin: 6px 0; 
            color: #1e40af; font-size: 1.1em;
        }
        .report-result { 
            font-weight: bold; color: #000; margin-top: 8px; padding: 6px; background: #f8fafc; 
        }
        .report-summary-box {
            background: white; color: #0f172a; padding: 12px; border: 2px solid #cbd5e1; 
            margin: 15px 0; text-align: center;
        }
        .report-summary-value { font-size: 20px; font-weight: bold; margin-top: 4px; color: #1e40af; }

    </style>
</head>
<body class="p-3 md:p-6 min-h-screen">

    <!-- Device-bound Login -->
    <div id="loginScreen" class="max-w-[640px] mx-auto bg-white rounded-2xl shadow-xl border border-slate-200 overflow-hidden">
        <div class="px-6 py-5 border-b border-slate-100 bg-gradient-to-br from-emerald-600 via-sky-600 to-blue-700 text-white relative overflow-hidden">
            <div class="absolute -top-10 -right-10 w-40 h-40 rounded-full bg-white/10 blur-2xl"></div>
            <div class="absolute -bottom-14 -left-14 w-48 h-48 rounded-full bg-white/10 blur-2xl"></div>
            <div class="flex items-center justify-center">
                <div class="bg-white/15 p-2 rounded-xl">
                    <i class="fa-solid fa-solar-panel text-xl"></i>
                </div>
            </div>
        </div>
        <div class="p-6 space-y-4 bg-gradient-to-b from-white to-slate-50">
            <div class="grid grid-cols-1 sm:grid-cols-3 gap-3">
                <div class="rounded-xl border border-emerald-100 bg-emerald-50/60 p-3">
                    <div class="text-emerald-700 font-bold text-xs flex items-center gap-2">
                        <i class="fa-solid fa-leaf"></i><span></span>
                    </div>
                </div>
                <div class="rounded-xl border border-sky-100 bg-sky-50/60 p-3">
                    <div class="text-sky-700 font-bold text-xs flex items-center gap-2">
                        <i class="fa-solid fa-sun"></i><span>太陽光電</span>
                    </div>
                </div>
                <div class="rounded-xl border border-blue-100 bg-blue-50/60 p-3">
                    <div class="text-blue-700 font-bold text-xs flex items-center gap-2">
                        <i class="fa-solid fa-chart-line"></i><span>工程規劃</span>
                    </div>
                </div>
            </div>

            <div class="text-sm text-slate-600 leading-relaxed">
                請輸入通行碼以進入系統。為確保授權安全，首次登入會綁定此裝置；之後僅允許同一裝置登入。
            </div>
            <form id="loginForm" class="space-y-3">
                <div class="space-y-1">
                    <label class="text-xs font-bold text-slate-500 uppercase">Passcode</label>
                    <input id="passcodeInput" type="password" autocomplete="one-time-code"
                           class="w-full border border-gray-300 rounded-lg p-3 bg-white focus:bg-white focus:ring-2 focus:ring-sky-500 outline-none transition font-mono"
                           placeholder="例如：666" required>
                </div>
                <button id="loginBtn" type="submit"
                        class="w-full bg-gradient-to-r from-emerald-600 via-sky-600 to-blue-700 hover:from-emerald-700 hover:via-sky-700 hover:to-blue-800 text-white font-bold py-3 rounded-lg transition shadow-md shadow-sky-200 disabled:opacity-60 disabled:cursor-not-allowed">
                    驗證並登入
                </button>
                <div id="loginMsg" class="text-sm text-red-600 font-semibold hidden"></div>
            </form>
        </div>
    </div>

    <!-- Main App (hidden until login success) -->
    <div id="appRoot" class="max-w-[1600px] mx-auto bg-white rounded-2xl shadow-xl min-h-[calc(100vh-3rem)] flex flex-col border border-slate-200 overflow-hidden hidden">
        
        <!-- Header -->
        <header class="px-6 py-4 border-b border-gray-100 flex flex-col md:flex-row justify-between items-center bg-white sticky top-0 z-40 shadow-sm">
            <div class="flex items-center gap-4">
                <div class="bg-gradient-to-br from-blue-600 to-blue-700 text-white p-2.5 rounded-xl shadow-lg shadow-blue-200">
                    <i class="fa-solid fa-solar-panel text-2xl"></i>
                </div>
                <div>
                    <h1 class="text-xl md:text-2xl font-bold text-slate-800 tracking-tight">太陽光電全方位規劃系統</h1>
                    <p class="text-xs text-slate-500 font-medium mt-0.5">串列規劃與驗證 | Engineering Design Tool</p>
                </div>
            </div>
            <div class="flex items-center gap-3 mt-4 md:mt-0">
                <button onclick="App.actions.saveState()" class="text-xs bg-slate-100 hover:bg-slate-200 text-slate-600 px-3 py-2 rounded-lg transition border border-slate-200"><i class="fa-solid fa-floppy-disk mr-1"></i> 儲存</button>
                <button onclick="App.actions.exportPDF()" class="text-xs bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded-lg transition shadow-md shadow-blue-200 flex items-center gap-1"><i class="fa-solid fa-file-pdf"></i> 匯出報告</button>
                <div id="dbStatus" class="text-xs px-4 py-2 rounded-full bg-slate-50 text-slate-500 font-medium border border-slate-200 flex items-center gap-2"><i class="fa-solid fa-circle-notch fa-spin text-blue-500"></i> 連線中...</div>
            </div>
        </header>

        <!-- Navigation -->
        <nav class="flex border-b border-gray-200 bg-white px-6 gap-2 overflow-x-auto shadow-sm z-30">
            <button class="tab-btn active" onclick="App.ui.switchTab('planning')"><i class="fa-solid fa-pen-ruler mr-2"></i>系統規劃</button>
            <button class="tab-btn" onclick="App.ui.switchTab('inverters')"><i class="fa-solid fa-server mr-2"></i>逆變器資料庫 (Inverters)</button>
            <button class="tab-btn" onclick="App.ui.switchTab('modules')"><i class="fa-solid fa-table-cells mr-2"></i>模組資料庫 (Modules)</button>
            <button class="tab-btn" onclick="App.ui.switchTab('cables')"><i class="fa-solid fa-book-open mr-2"></i>電纜安培容量及配管</button>
            <button class="tab-btn" onclick="App.ui.switchTab('help')"><i class="fa-solid fa-circle-question mr-2"></i>說明</button>
        </nav>

        <!-- Main Content -->
        <main class="flex-grow p-4 md:p-6 bg-slate-50/50">

            <!-- TAB 1: 系統規劃 -->
            <div id="tab-planning" class="tab-content active">
                <div class="space-y-6">
                    
                    <!-- Row 1: 參數與選型 -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        
                        <!-- 1. 基礎參數 -->
                        <div class="bg-white p-5 rounded-xl border border-gray-200 shadow-sm h-full flex flex-col">
                            <h3 class="font-bold text-slate-800 mb-4 flex items-center text-lg">
                                <span class="bg-blue-600 text-white rounded-md w-7 h-7 flex items-center justify-center text-sm mr-3 font-mono">1</span>
                                系統基礎參數
                            </h3>
                            <div class="space-y-4">
                                <div class="grid grid-cols-12 gap-4 items-start">
                                    <div class="space-y-1 col-span-12 md:col-span-4">
                                        <label class="text-xs font-bold text-slate-500 uppercase">電壓 (V)</label>
                                        <select id="gridVoltage" class="inp-param w-full border border-gray-300 rounded-lg p-2.5 bg-gray-50 focus:bg-white focus:ring-2 focus:ring-blue-500 outline-none transition">
                                            <option value="380" selected>380V (3Φ)</option>
                                            <option value="220">220V (3Φ)</option>
                                            <option value="220_1ph">220V (1Φ)</option>
                                            <option value="440">440V (3Φ)</option>
                                            <option value="480">480V (3Φ)</option>
                                        </select>
                                    </div>
                                    <div class="space-y-1 col-span-12 md:col-span-8">
                                        <div class="flex items-center justify-between">
                                            <label class="text-xs font-bold text-slate-500 uppercase">屋頂清單 (Roofs)</label>
                                            <button type="button" id="addRoofBtn" class="text-xs bg-slate-100 hover:bg-slate-200 text-slate-700 px-3 py-1.5 rounded-lg transition border border-slate-200 font-bold">
                                                <i class="fa-solid fa-plus mr-1"></i>新增屋頂
                                            </button>
                                        </div>
                                        <div id="roofList" class="space-y-2"></div>
                                        <div class="text-[11px] text-slate-500 pl-1">可新增/刪除屋頂；每一屋頂可輸入規劃片數（系統會自動加總成「規劃總片數」）</div>
                                    </div>
                                </div>
                                
                                <div class="space-y-1">
                                    <label class="text-xs font-bold text-slate-500 uppercase text-blue-600">選用光電模組 (PV Module)</label>
                                    <select id="activeModuleSelect" class="inp-param w-full border-2 border-blue-100 rounded-lg p-2.5 text-slate-700 font-bold focus:border-blue-500 outline-none transition">
                                        <option value="">讀取中...</option>
                                    </select>
                                    <div id="moduleSpecsDisplay" class="text-xs text-gray-500 mt-1 pl-1"></div>
                                </div>

                                <div class="grid grid-cols-2 gap-4">
                                    <div class="space-y-1">
                                        <label class="text-xs font-bold text-slate-500 uppercase">規劃總片數 (Panels)</label>
                                        <div class="relative">
                                            <input type="number" id="plannedPanels" class="inp-param w-full border border-gray-300 rounded-lg p-2.5 text-blue-700 font-bold bg-slate-50" placeholder="0" value="0" min="0" readonly>
                                            <span class="absolute right-4 top-3.5 text-gray-400 text-sm font-bold">片</span>
                                        </div>
                                        <div id="calculatedCapacity" class="text-xs text-gray-500 mt-1 pl-1">
                                            <span class="font-semibold">計算容量:</span> <span id="capacityValue">0.00 kW</span>
                                        </div>
                                    </div>
                                    <div class="space-y-1">
                                        <label class="text-xs font-bold text-slate-500 uppercase">短路容量 (MVA)</label>
                                        <input type="number" id="sourceMVA" value="250" class="inp-param w-full border border-gray-300 rounded-lg p-2.5 bg-gray-50 text-slate-600 focus:bg-white transition">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- 2. 設備清單 -->
                        <div class="bg-white p-5 rounded-xl border border-gray-200 shadow-sm flex flex-col h-full">
                            <div class="flex justify-between items-center mb-4">
                                <h3 class="font-bold text-slate-800 flex items-center text-lg">
                                    <span class="bg-slate-700 text-white rounded-md w-7 h-7 flex items-center justify-center text-sm mr-3 font-mono">2</span>
                                    逆變器配置
                                </h3>
                                <button onclick="App.ui.addInverterRow()" class="text-blue-600 hover:bg-blue-50 px-3 py-1 rounded-full text-sm font-bold flex items-center gap-1 transition border border-transparent hover:border-blue-100">
                                    <i class="fa-solid fa-plus"></i> 新增
                                </button>
                            </div>
                            <div class="overflow-y-auto border border-gray-200 rounded-lg flex-grow max-h-[300px] custom-scrollbar">
                                <table class="w-full text-sm">
                                    <thead class="bg-gray-50 text-gray-500 border-b border-gray-200 sticky top-0 z-10">
                                        <tr><th class="p-2 text-left pl-3">型號 & 參數</th><th class="p-2 w-20 text-center">超配比%</th><th class="p-2 w-16 text-center">數量</th><th class="p-2 w-10"></th></tr>
                                    </thead>
                                    <tbody id="inverterListBody" class="divide-y divide-gray-100 bg-white"></tbody>
                                </table>
                            </div>
                            <div class="mt-3 flex justify-between items-center bg-blue-50 p-3 rounded-lg border border-blue-100 text-blue-900">
                                <span class="text-xs font-bold">逆變器總額定功率</span>
                                <span class="text-lg font-bold" id="inverterTotalDisplay">0.00 kW</span>
                            </div>
                        </div>
                    </div>

                    <!-- Row 2: 逆變器規劃結果 (新功能) -->
                    <div class="bg-white rounded-xl border border-gray-200 shadow-sm p-5">
                        <div class="border-b border-gray-100 pb-4 mb-4 flex justify-between items-center">
                            <h3 class="font-bold text-slate-800 flex items-center text-lg">
                                <span class="bg-teal-600 text-white rounded-md w-7 h-7 flex items-center justify-center text-sm mr-3 font-mono">3</span>
                                逆變器規劃結果 (String Sizing)
                            </h3>
                            <span class="text-xs text-gray-400">邏輯: 每一MPPT串列數量相等 / 優先跨屋頂利用MPPT</span>
                        </div>
                        
                        <div id="planningResults" class="grid grid-cols-1 xl:grid-cols-2 gap-4">
                            <div class="text-center text-gray-400 p-8 border-2 border-dashed rounded-lg col-span-full">
                                請選擇模組、加入逆變器並設定超配比以開始規劃...
                            </div>
                        </div>
                    </div>

                    <!-- Row 3: 單線圖 -->
                    <div class="bg-white rounded-xl border border-gray-200 shadow-sm overflow-hidden">
                        <div class="p-5 border-b border-gray-100 flex justify-between items-center bg-gray-50/50">
                            <h3 class="font-bold text-slate-800 flex items-center text-lg">
                                <span class="bg-purple-600 text-white rounded-md w-7 h-7 flex items-center justify-center text-sm mr-3 font-mono">4</span>
                                單線圖架構 (SLD)
                            </h3>
                            <label class="inline-flex items-center cursor-pointer select-none bg-white border border-gray-200 px-4 py-1.5 rounded-full hover:bg-gray-50 transition shadow-sm">
                                <input type="checkbox" id="hasTransformer" class="inp-param form-checkbox h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500">
                                <span class="ml-2 text-sm font-bold text-slate-700">含變壓器</span>
                            </label>
                        </div>
                        <div class="w-full overflow-x-auto custom-scrollbar bg-white">
                            <div class="flex items-start justify-start lg:justify-center min-w-[900px] p-10 gap-4">
                                <div class="sld-node w-40 p-5 text-center rounded-xl flex-shrink-0 z-10"><div class="text-3xl text-blue-600 mb-3"><i class="fa-solid fa-tower-cell"></i></div><div class="font-bold text-base text-slate-800">台電電網</div><div class="text-xs text-slate-500 mt-1 font-mono">Source</div></div>
                                <div class="flex flex-col items-center w-56 sld-line-group flex-shrink-0 group"><div class="text-[10px] text-slate-400 font-bold mb-1 uppercase tracking-wider">責任分界點</div><div class="h-1.5 bg-slate-200 w-full relative rounded-full group-hover:bg-blue-200 transition"></div><div class="mt-3 w-full space-y-2 px-1"><select id="cableSelect1" class="inp-param w-full text-xs border border-gray-300 rounded p-2 focus:ring-1 focus:ring-blue-500 outline-none shadow-sm"></select><div class="flex items-center bg-gray-50 rounded border border-gray-200 px-2 focus-within:ring-1 focus-within:ring-blue-500 shadow-sm"><input type="number" id="len1" value="10" class="inp-param w-full text-xs bg-transparent p-2 outline-none font-medium text-center" placeholder="長度"><span class="text-xs text-gray-400 mr-1">m</span></div><div id="drop1" class="text-[10px] font-mono text-center text-blue-600 font-bold h-4"></div></div></div>
                                <div class="sld-node w-40 p-5 text-center rounded-xl flex-shrink-0 z-10"><div class="text-3xl text-blue-600 mb-3"><i class="fa-solid fa-tachograph-digital"></i></div><div class="font-bold text-base text-slate-800">MOF / 表箱</div><div class="text-xs text-slate-500 mt-1 font-mono">Metering</div></div>
                                <div class="flex flex-col items-center w-56 sld-line-group flex-shrink-0 group"><div class="text-[10px] text-slate-400 font-bold mb-1 uppercase tracking-wider">幹線迴路</div><div class="h-1.5 bg-slate-200 w-full relative rounded-full group-hover:bg-blue-200 transition"></div><div class="mt-3 w-full space-y-2 px-1"><select id="cableSelect2" class="inp-param w-full text-xs border border-gray-300 rounded p-2 focus:ring-1 focus:ring-blue-500 outline-none shadow-sm"></select><div class="flex items-center bg-gray-50 rounded border border-gray-200 px-2 focus-within:ring-1 focus-within:ring-blue-500 shadow-sm"><input type="number" id="len2" value="50" class="inp-param w-full text-xs bg-transparent p-2 outline-none font-medium text-center" placeholder="長度"><span class="text-xs text-gray-400 mr-1">m</span></div><div id="drop2" class="text-[10px] font-mono text-center text-blue-600 font-bold h-4"></div></div></div>
                                <div id="transSection" class="hidden flex items-start gap-4"><div class="sld-node w-40 p-5 text-center rounded-xl flex-shrink-0 z-10 border-l-4 !border-l-amber-500 !bg-amber-50/30"><div class="text-3xl text-amber-500 mb-3"><i class="fa-solid fa-bolt"></i></div><div class="font-bold text-base text-slate-800">變壓器</div><div id="transInfo" class="text-xs text-amber-600 font-bold mt-1 font-mono">Z% Auto</div></div><div class="flex flex-col items-center w-56 sld-line-group flex-shrink-0 group"><div class="text-[10px] text-slate-400 font-bold mb-1 uppercase tracking-wider">二次側線路</div><div class="h-1.5 bg-slate-200 w-full relative rounded-full group-hover:bg-blue-200 transition"></div><div class="mt-3 w-full space-y-2 px-1"><select id="cableSelect3" class="inp-param w-full text-xs border border-gray-300 rounded p-2 focus:ring-1 focus:ring-blue-500 outline-none shadow-sm"></select><div class="flex items-center bg-gray-50 rounded border border-gray-200 px-2 focus-within:ring-1 focus-within:ring-blue-500 shadow-sm"><input type="number" id="len3" value="20" class="inp-param w-full text-xs bg-transparent p-2 outline-none font-medium text-center" placeholder="長度"><span class="text-xs text-gray-400 mr-1">m</span></div><div id="drop3" class="text-[10px] font-mono text-center text-blue-600 font-bold h-4"></div></div></div></div>
                                <div class="sld-node w-40 p-5 text-center rounded-xl flex-shrink-0 z-10 border-l-4 !border-l-green-500"><div class="text-3xl text-green-600 mb-3"><i class="fa-solid fa-server"></i></div><div class="font-bold text-base text-slate-800">逆變器群</div><div class="text-xs text-slate-500 mt-1 font-mono">AC Output</div></div>
                            </div>
                        </div>
                    </div>

                    <!-- Row 4: 計算報告 -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div class="bg-white p-1 rounded-xl border border-gray-200 shadow-sm flex flex-col h-[500px] overflow-hidden"><div class="bg-gray-50 p-3 border-b border-gray-200 flex items-center justify-between"><h4 class="font-bold text-slate-700 text-sm"><i class="fa-solid fa-chart-line text-blue-500 mr-2"></i>電壓降計算書</h4></div><div id="dropLog" class="console-box flex-grow p-4 overflow-y-auto text-xs leading-relaxed space-y-2 m-2 rounded-lg">等待計算...</div></div>
                        <div class="bg-white p-1 rounded-xl border border-gray-200 shadow-sm flex flex-col h-[500px] overflow-hidden"><div class="bg-gray-50 p-3 border-b border-gray-200 flex items-center justify-between"><h4 class="font-bold text-slate-700 text-sm"><i class="fa-solid fa-burst text-red-500 mr-2"></i>短路電流計算書</h4></div><div id="scLog" class="console-box flex-grow p-4 overflow-y-auto text-xs leading-relaxed space-y-2 m-2 rounded-lg">等待計算...</div></div>
                    </div>
                </div>
            </div>

            <!-- Tab 2/3/4 (Keep same structure but simplified for brevity in this output, functionally identical) -->
            <div id="tab-inverters" class="tab-content">
                <div class="bg-white p-4 rounded-xl border border-gray-200 shadow-sm mb-6 flex items-center gap-4"><h2 class="text-lg font-bold text-slate-800">逆變器資料庫 (Inverters)</h2><input type="text" placeholder="搜尋..." class="border border-gray-300 p-2 rounded text-sm w-64" onkeyup="App.ui.filterTable('inverterTable',this.value)"></div>
                <div class="bg-white rounded-xl border border-gray-200 shadow-sm overflow-auto"><table id="inverterTable" class="w-full text-sm text-left"><thead class="bg-gray-50 text-gray-600 font-bold border-b"><tr><th class="p-3">型號<br><span class="text-xs font-normal">Model</span></th><th class="p-3">功率<br><span class="text-xs font-normal">Power (kW)</span></th><th class="p-3">電壓<br><span class="text-xs font-normal">Voltage (V)</span></th><th class="p-3">MPPT<br><span class="text-xs font-normal">Trackers</span></th><th class="p-3">效率<br><span class="text-xs font-normal">Efficiency</span></th><th class="p-3">詳細<br><span class="text-xs font-normal">Detail</span></th></tr></thead><tbody id="inverterTableBody"></tbody></table></div>
            </div>
            <div id="tab-modules" class="tab-content">
                <div class="bg-white p-4 rounded-xl border border-gray-200 shadow-sm mb-6 flex items-center gap-4"><h2 class="text-lg font-bold text-slate-800">模組資料庫 (Modules)</h2><input type="text" placeholder="搜尋..." class="border border-gray-300 p-2 rounded text-sm w-64" onkeyup="App.ui.filterTable('moduleTable',this.value)"></div>
                <div class="bg-white rounded-xl border border-gray-200 shadow-sm overflow-auto"><table id="moduleTable" class="w-full text-sm text-left"><thead class="bg-gray-50 text-gray-600 font-bold border-b"><tr><th class="p-3">廠牌<br><span class="text-xs font-normal">Brand</span></th><th class="p-3">型號<br><span class="text-xs font-normal">Model</span></th><th class="p-3">功率<br><span class="text-xs font-normal">Power (W)</span></th><th class="p-3">Voc<br><span class="text-xs font-normal">Open Circuit</span></th><th class="p-3">Isc<br><span class="text-xs font-normal">Short Circuit</span></th><th class="p-3">詳細<br><span class="text-xs font-normal">Detail</span></th></tr></thead><tbody id="moduleTableBody"></tbody></table></div>
            </div>
            <div id="tab-cables" class="tab-content">
                <div class="bg-white rounded-xl border border-gray-200 shadow-sm p-5">
                    <h3 class="font-bold text-blue-700 mb-4 border-b pb-2">電纜安培容量及配管 (Cable Ampacity & Conduit)</h3>
                    
                    <!-- 安培容量表 -->
                    <div class="mb-6">
                        <h4 class="font-bold text-slate-700 mb-3 text-sm">導線安培容量表 (Ampacity Table)</h4>
                        <div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-6 text-xs">
                            <div class="border rounded shadow-sm">
                                <div class="bg-gray-100 p-2 text-center font-bold border-b">PVC (60℃)</div>
                                <div class="h-80 overflow-auto">
                                    <table class="w-full text-center">
                                        <thead class="bg-slate-50 sticky top-0" id="ampTablePVCHeader"></thead>
                                        <tbody id="ampTablePVC"></tbody>
                                    </table>
                                </div>
                            </div>
                            <div class="border rounded shadow-sm">
                                <div class="bg-gray-100 p-2 text-center font-bold border-b">金屬管 (60℃)</div>
                                <div class="h-80 overflow-auto">
                                    <table class="w-full text-center">
                                        <thead class="bg-slate-50 sticky top-0" id="ampTableMetal60Header"></thead>
                                        <tbody id="ampTableMetal60"></tbody>
                                    </table>
                                </div>
                            </div>
                            <div class="border rounded border-blue-200 shadow-sm">
                                <div class="bg-blue-50 p-2 text-center font-bold text-blue-800 border-b">金屬管 (75℃ XLPE)</div>
                                <div class="h-80 overflow-auto">
                                    <table class="w-full text-center">
                                        <thead class="bg-blue-50 sticky top-0" id="ampTableMetal75Header"></thead>
                                        <tbody id="ampTableMetal75"></tbody>
                                    </table>
                                </div>
                            </div>
                            <div class="border rounded border-red-200 shadow-sm">
                                <div class="bg-red-50 p-2 text-center font-bold text-red-800 border-b">金屬管 (90℃)</div>
                                <div class="h-80 overflow-auto">
                                    <table class="w-full text-center">
                                        <thead class="bg-red-50 sticky top-0" id="ampTableMetal90Header"></thead>
                                        <tbody id="ampTableMetal90"></tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 管徑表與阻抗表 -->
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        <div class="bg-white rounded-xl border border-gray-200 shadow-sm p-5 h-[450px] flex flex-col">
                            <h4 class="font-bold text-slate-700 mb-2 border-b pb-2">管徑表 - 非金屬管 (PVC)</h4>
                            <div class="overflow-auto flex-grow text-xs border rounded" style="overflow-x: auto; overflow-y: auto;">
                                <table class="text-center" style="min-width: 100%;">
                                    <thead class="bg-gray-50 sticky top-0">
                                        <tr id="pipeTableHeader"></tr>
                                    </thead>
                                    <tbody id="pipeTableBody"></tbody>
                                </table>
                            </div>
                        </div>
                        <div class="bg-white rounded-xl border border-gray-200 shadow-sm p-5 h-[450px] flex flex-col">
                            <h4 class="font-bold text-slate-700 mb-2 border-b pb-2">管徑表 - 非金屬軟管</h4>
                            <div class="overflow-auto flex-grow text-xs border rounded" style="overflow-x: auto; overflow-y: auto;">
                                <table class="text-center" style="min-width: 100%;">
                                    <thead class="bg-gray-50 sticky top-0">
                                        <tr id="pipeTableFlexNonMetalHeader"></tr>
                                    </thead>
                                    <tbody id="pipeTableFlexNonMetalBody"></tbody>
                                </table>
                            </div>
                        </div>
                        <div class="bg-white rounded-xl border border-gray-200 shadow-sm p-5 h-[450px] flex flex-col">
                            <h4 class="font-bold text-slate-700 mb-2 border-b pb-2">管徑表 - 金屬薄管</h4>
                            <div class="overflow-auto flex-grow text-xs border rounded" style="overflow-x: auto; overflow-y: auto;">
                                <table class="text-center" style="min-width: 100%;">
                                    <thead class="bg-gray-50 sticky top-0">
                                        <tr id="pipeTableThinMetalHeader"></tr>
                                    </thead>
                                    <tbody id="pipeTableThinMetalBody"></tbody>
                                </table>
                            </div>
                        </div>
                        <div class="bg-white rounded-xl border border-gray-200 shadow-sm p-5 h-[450px] flex flex-col">
                            <h4 class="font-bold text-slate-700 mb-2 border-b pb-2">管徑表 - 金屬厚管</h4>
                            <div class="overflow-auto flex-grow text-xs border rounded" style="overflow-x: auto; overflow-y: auto;">
                                <table class="text-center" style="min-width: 100%;">
                                    <thead class="bg-gray-50 sticky top-0">
                                        <tr id="pipeTableThickMetalHeader"></tr>
                                    </thead>
                                    <tbody id="pipeTableThickMetalBody"></tbody>
                                </table>
                            </div>
                        </div>
                        <div class="bg-white rounded-xl border border-gray-200 shadow-sm p-5 h-[450px] flex flex-col">
                            <h4 class="font-bold text-slate-700 mb-2 border-b pb-2">阻抗參數 (25℃) (Impedance @ 25℃)</h4>
                            <div class="overflow-auto flex-grow text-xs border rounded">
                                <table class="w-full text-center">
                                    <thead class="bg-gray-50 sticky top-0">
                                        <tr><th class="p-2">種類</th><th class="p-2">線徑</th><th class="p-2">R (Ω/km)</th><th class="p-2">X (Ω/km)</th></tr>
                                    </thead>
                                    <tbody id="impedanceTableBody"></tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- 接地 / 斷路器標準 -->
                    <div class="mt-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        <div class="bg-white rounded-xl border border-gray-200 shadow-sm p-5 h-[450px] flex flex-col">
                            <h4 class="font-bold text-slate-700 mb-2 border-b pb-2">接地種類 (Ground Types)</h4>
                            <div class="overflow-auto flex-grow text-xs border rounded">
                                <table class="w-full text-center">
                                    <thead class="bg-gray-50 sticky top-0" id="groundTypeTableHeader"></thead>
                                    <tbody id="groundTypeTableBody"></tbody>
                                </table>
                            </div>
                        </div>
                        <div class="bg-white rounded-xl border border-gray-200 shadow-sm p-5 h-[450px] flex flex-col">
                            <h4 class="font-bold text-slate-700 mb-2 border-b pb-2">接地導線線徑 (Grounding Conductor Wire Sizing)</h4>
                            <div class="overflow-auto flex-grow text-xs border rounded">
                                <table class="w-full text-center">
                                    <thead class="bg-gray-50 sticky top-0" id="groundingConductorWireSizingTableHeader"></thead>
                                    <tbody id="groundingConductorWireSizingTableBody"></tbody>
                                </table>
                            </div>
                        </div>
                        <div class="bg-white rounded-xl border border-gray-200 shadow-sm p-5 h-[450px] flex flex-col">
                            <h4 class="font-bold text-slate-700 mb-2 border-b pb-2">斷路器標準 (Breaker Standards)</h4>
                            <div class="overflow-auto flex-grow text-xs border rounded">
                                <table class="w-full text-center">
                                    <thead class="bg-gray-50 sticky top-0" id="breakerStdTableHeader"></thead>
                                    <tbody id="breakerStdTableBody"></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tab 5: 說明 -->
            <div id="tab-help" class="tab-content">
                <div class="bg-white rounded-xl border border-gray-200 shadow-sm p-6">
                    <div class="mb-6">
                        <h2 class="text-2xl font-bold text-slate-800 mb-2 flex items-center">
                            <i class="fa-solid fa-circle-question text-blue-600 mr-3"></i>
                            逆變器規劃邏輯說明
                        </h2>
                        <p class="text-gray-600 text-sm">Inverter Planning Logic Documentation</p>
                    </div>

                    <div class="space-y-6">
                        <!-- 1. 基本原則 -->
                        <div class="bg-blue-50 border-l-4 border-blue-500 p-5 rounded-r-lg">
                            <h3 class="text-lg font-bold text-blue-800 mb-3 flex items-center">
                                <i class="fa-solid fa-lightbulb mr-2"></i>
                                1. 基本規劃原則 (Basic Planning Principles)
                            </h3>
                            <ul class="space-y-2 text-sm text-gray-700">
                                <li class="flex items-start">
                                    <i class="fa-solid fa-check-circle text-blue-500 mr-2 mt-1"></i>
                                    <span><strong>片數分配：</strong>系統根據使用者輸入的「規劃片數」進行分配，每個逆變器分配的片數依其功率比例計算，最後一個逆變器會接收剩餘的所有片數，確保總數等於使用者輸入的規劃片數。</span>
                                </li>
                                <li class="flex items-start">
                                    <i class="fa-solid fa-check-circle text-blue-500 mr-2 mt-1"></i>
                                    <span><strong>DC/AC 超配比：</strong>使用者可以為每個逆變器設定個別的 DC/AC 超配比，系統會根據此比例調整逆變器的實際配置容量。</span>
                                </li>
                                <li class="flex items-start">
                                    <i class="fa-solid fa-check-circle text-blue-500 mr-2 mt-1"></i>
                                    <span><strong>MPPT 配置：</strong>不一定每個 MPPT 都要配到極限值，系統會智能調配已分配的 MPPT，優先充分利用所有可用的 MPPT。</span>
                                </li>
                            </ul>
                        </div>

                        <!-- 2. 串列限制 -->
                        <div class="bg-green-50 border-l-4 border-green-500 p-5 rounded-r-lg">
                            <h3 class="text-lg font-bold text-green-800 mb-3 flex items-center">
                                <i class="fa-solid fa-ruler-horizontal mr-2"></i>
                                2. 串列片數限制 (String Panel Count Limits)
                            </h3>
                            <div class="space-y-3 text-sm text-gray-700">
                                <div>
                                    <p class="font-semibold mb-2">串列片數必須符合以下條件：</p>
                                    <ul class="space-y-1 ml-4">
                                        <li class="flex items-start">
                                            <i class="fa-solid fa-arrow-right text-green-600 mr-2 mt-1"></i>
                                            <span><strong>Nmin(75°C) ≤ N &lt; Nmax(0°C)</strong></span>
                                        </li>
                                        <li class="flex items-start">
                                            <i class="fa-solid fa-arrow-right text-green-600 mr-2 mt-1"></i>
                                            <span><strong>Nmin：</strong>基於 75°C 時的 Vmp 和 MPPT 最小工作電壓範圍計算</span>
                                        </li>
                                        <li class="flex items-start">
                                            <i class="fa-solid fa-arrow-right text-green-600 mr-2 mt-1"></i>
                                            <span><strong>Nmax：</strong>基於 0°C 時的 Voc 和逆變器最大輸入電壓計算（系統耐壓限制）</span>
                                        </li>
                                        <li class="flex items-start">
                                            <i class="fa-solid fa-arrow-right text-green-600 mr-2 mt-1"></i>
                                            <span><strong>允許範圍：</strong>可允許片數小於串列限制，但不能大於最大限制</span>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <!-- 3. 電壓範圍檢查 -->
                        <div class="bg-yellow-50 border-l-4 border-yellow-500 p-5 rounded-r-lg">
                            <h3 class="text-lg font-bold text-yellow-800 mb-3 flex items-center">
                                <i class="fa-solid fa-gauge mr-2"></i>
                                3. 電壓範圍檢查 (Voltage Range Validation)
                            </h3>
                            <div class="space-y-3 text-sm text-gray-700">
                                <div>
                                    <p class="font-semibold mb-2">系統會檢查以下電壓條件：</p>
                                    <ul class="space-y-1 ml-4">
                                        <li class="flex items-start">
                                            <i class="fa-solid fa-bolt text-yellow-600 mr-2 mt-1"></i>
                                            <span><strong>0°C 系統耐壓：</strong>Voc(0°C) × N 不能超過逆變器最大輸入電壓（必須滿足，不能超過）</span>
                                        </li>
                                        <li class="flex items-start">
                                            <i class="fa-solid fa-bolt text-yellow-600 mr-2 mt-1"></i>
                                            <span><strong>75°C MPPT 範圍：</strong>Vmp(75°C) × N 應在 MPPT 工作電壓範圍內（mppt_min ~ mppt_max）</span>
                                        </li>
                                        <li class="flex items-start">
                                            <i class="fa-solid fa-bolt text-yellow-600 mr-2 mt-1"></i>
                                            <span><strong>電壓過低判斷：</strong>只有當某串電壓小於操作電壓（rated_input_voltage）時才顯示「電壓過低」</span>
                                        </li>
                                        <li class="flex items-start">
                                            <i class="fa-solid fa-bolt text-yellow-600 mr-2 mt-1"></i>
                                            <span><strong>允許配置：</strong>即使電壓在工作電壓範圍內（不算電壓過低），也會配置進去</span>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <!-- 4. MPPT 配置策略 -->
                        <div class="bg-purple-50 border-l-4 border-purple-500 p-5 rounded-r-lg">
                            <h3 class="text-lg font-bold text-purple-800 mb-3 flex items-center">
                                <i class="fa-solid fa-sitemap mr-2"></i>
                                4. MPPT 配置策略 (MPPT Configuration Strategy)
                            </h3>
                            <div class="space-y-3 text-sm text-gray-700">
                                <div>
                                    <p class="font-semibold mb-2">MPPT 分配邏輯：</p>
                                    <ul class="space-y-1 ml-4">
                                        <li class="flex items-start">
                                            <i class="fa-solid fa-arrow-right text-purple-600 mr-2 mt-1"></i>
                                            <span><strong>並聯限制：</strong>每個 MPPT 的並聯串數不能超過 MPPT 最大輸入電流限制（基於模組最大功率點電流 I_mp 計算）</span>
                                        </li>
                                        <li class="flex items-start">
                                            <i class="fa-solid fa-arrow-right text-purple-600 mr-2 mt-1"></i>
                                            <span><strong>單一 MPPT：</strong>當 MPPT 數量為 1 時，優先考慮每條串列相等，並優先配置在工作電壓範圍內</span>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <!-- 5. 電流限制 -->
                        <div class="bg-red-50 border-l-4 border-red-500 p-5 rounded-r-lg">
                            <h3 class="text-lg font-bold text-red-800 mb-3 flex items-center">
                                <i class="fa-solid fa-plug mr-2"></i>
                                5. MPPT 電流限制 (MPPT Current Limits)
                            </h3>
                            <div class="space-y-3 text-sm text-gray-700">
                                <div>
                                    <p class="font-semibold mb-2">電流計算與限制：</p>
                                    <ul class="space-y-1 ml-4">
                                        <li class="flex items-start">
                                            <i class="fa-solid fa-arrow-right text-red-600 mr-2 mt-1"></i>
                                            <span><strong>模組電流：</strong>使用模組的最大功率點電流（I_mp），而非短路電流（I_sc）</span>
                                        </li>
                                        <li class="flex items-start">
                                            <i class="fa-solid fa-arrow-right text-red-600 mr-2 mt-1"></i>
                                            <span><strong>總電流：</strong>總電流 = 並聯串數 × I_mp</span>
                                        </li>
                                        <li class="flex items-start">
                                            <i class="fa-solid fa-arrow-right text-red-600 mr-2 mt-1"></i>
                                            <span><strong>最大並聯數：</strong>可並聯最多串數 = MPPT 最大輸入電流 ÷ I_mp</span>
                                        </li>
                                        <li class="flex items-start">
                                            <i class="fa-solid fa-arrow-right text-red-600 mr-2 mt-1"></i>
                                            <span><strong>特殊機型：</strong>對於 M125HV 系列，使用「Max Input Current Total A」並除以 MPPT 數量得到每 MPPT 電流</span>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <!-- 6. 屋頂分配 -->
                        <div class="bg-indigo-50 border-l-4 border-indigo-500 p-5 rounded-r-lg">
                            <h3 class="text-lg font-bold text-indigo-800 mb-3 flex items-center">
                                <i class="fa-solid fa-building mr-2"></i>
                                6. 屋頂分配原則 (Roof Assignment Principles)
                            </h3>
                            <div class="space-y-3 text-sm text-gray-700">
                                <ul class="space-y-1 ml-4">
                                    <li class="flex items-start">
                                        <i class="fa-solid fa-arrow-right text-indigo-600 mr-2 mt-1"></i>
                                        <span><strong>同 MPPT 同屋頂：</strong>同一個 MPPT 上的串列必須來自同一個屋頂</span>
                                    </li>
                                    <li class="flex items-start">
                                        <i class="fa-solid fa-arrow-right text-indigo-600 mr-2 mt-1"></i>
                                        <span><strong>不同 MPPT 可跨屋頂：</strong>不同 MPPT 可以跨不同屋頂，以充分利用逆變器</span>
                                    </li>
                                    <li class="flex items-start">
                                        <i class="fa-solid fa-arrow-right text-indigo-600 mr-2 mt-1"></i>
                                        <span><strong>循環分配：</strong>系統會根據使用者設定的「屋頂清單」循環分配 MPPT 到不同屋頂</span>
                                    </li>
                                </ul>
                            </div>
                        </div>

                        <!-- 7. 狀態顯示 -->
                        <div class="bg-gray-50 border-l-4 border-gray-500 p-5 rounded-r-lg">
                            <h3 class="text-lg font-bold text-gray-800 mb-3 flex items-center">
                                <i class="fa-solid fa-info-circle mr-2"></i>
                                7. 狀態顯示說明 (Status Display)
                            </h3>
                            <div class="space-y-3 text-sm text-gray-700">
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                                    <div class="bg-white p-3 rounded border border-green-200">
                                        <div class="flex items-center mb-2">
                                            <span class="bg-green-100 text-green-800 px-2 py-1 rounded text-xs font-bold mr-2">OK</span>
                                            <span class="font-semibold">正常配置</span>
                                        </div>
                                        <p class="text-xs text-gray-600">電壓和電流都在允許範圍內</p>
                                    </div>
                                    <div class="bg-white p-3 rounded border border-yellow-200">
                                        <div class="flex items-center mb-2">
                                            <span class="bg-yellow-100 text-yellow-800 px-2 py-1 rounded text-xs font-bold mr-2">警告</span>
                                            <span class="font-semibold">電壓過高</span>
                                        </div>
                                        <p class="text-xs text-gray-600">可能超過 MPPT 最大值或系統耐壓</p>
                                    </div>
                                    <div class="bg-white p-3 rounded border border-red-200">
                                        <div class="flex items-center mb-2">
                                            <span class="bg-red-100 text-red-800 px-2 py-1 rounded text-xs font-bold mr-2">錯誤</span>
                                            <span class="font-semibold">電壓過低</span>
                                        </div>
                                        <p class="text-xs text-gray-600">低於 MPPT 工作電壓範圍最小值</p>
                                    </div>
                                    <div class="bg-white p-3 rounded border border-red-200">
                                        <div class="flex items-center mb-2">
                                            <span class="bg-red-100 text-red-800 px-2 py-1 rounded text-xs font-bold mr-2">錯誤</span>
                                            <span class="font-semibold">電流超限</span>
                                        </div>
                                        <p class="text-xs text-gray-600">總電流超過 MPPT 最大輸入電流</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- 8. 注意事項 -->
                        <div class="bg-orange-50 border-l-4 border-orange-500 p-5 rounded-r-lg">
                            <h3 class="text-lg font-bold text-orange-800 mb-3 flex items-center">
                                <i class="fa-solid fa-exclamation-triangle mr-2"></i>
                                8. 注意事項 (Important Notes)
                            </h3>
                            <div class="space-y-2 text-sm text-gray-700">
                                <div class="flex items-start">
                                    <i class="fa-solid fa-circle-exclamation text-orange-600 mr-2 mt-1"></i>
                                    <span>如果逆變器無法配置所有片數，系統會顯示警告訊息，建議更改逆變器型號、數量、調整 DC/AC 超配比或檢查串列限制</span>
                                </div>
                                <div class="flex items-start">
                                    <i class="fa-solid fa-circle-exclamation text-orange-600 mr-2 mt-1"></i>
                                    <span>系統會優先配置符合電壓範圍要求的串列，不強制使用所有 MPPT，避免造成電壓過低</span>
                                </div>
                                <div class="flex items-start">
                                    <i class="fa-solid fa-circle-exclamation text-orange-600 mr-2 mt-1"></i>
                                    <span>即使電壓在工作電壓範圍內（不算電壓過低），系統也會配置進去，不一定每個 MPPT 都要配到極限值</span>
                                </div>
                                <div class="flex items-start">
                                    <i class="fa-solid fa-circle-exclamation text-orange-600 mr-2 mt-1"></i>
                                    <span>系統會顯示每個 MPPT 的詳細配置資訊，包括串列數、片數、電壓（STC、75°C、0°C）、電流和狀態</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </main>
    </div>

    <!-- Hidden Report Container -->
    <div id="pdf-report-container"></div>
    <!-- Modal -->
    <div id="detailModal" class="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 backdrop-blur-sm hidden" onclick="App.ui.closeModal()"><div class="bg-white w-[95%] max-w-4xl max-h-[90vh] rounded-2xl shadow-2xl flex flex-col overflow-hidden" onclick="event.stopPropagation()"><div class="p-5 border-b flex justify-between"><h2 id="modalTitle" class="text-xl font-bold"></h2><button onclick="App.ui.closeModal()" class="w-8 h-8 rounded-full bg-gray-100 hover:bg-gray-200"><i class="fa-solid fa-xmark"></i></button></div><div id="modalBody" class="p-6 overflow-y-auto"></div></div></div>

    <script>
        const CONFIG = {
            // Supabase project settings
            // 若需更換環境，將下列 URL / ANON KEY 改成你的專案設定即可。
            supabaseUrl: 'https://ntlmothsjvhdvcykcvex.supabase.co',
            supabaseKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im50bG1vdGhzanZoZHZjeWtjdmV4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU1NzEwMzIsImV4cCI6MjA4MTE0NzAzMn0.Fk2zZB7myLQnwx4Hiw678ggQYZ8ZaZDAW7UHH8eobO0',
            storageUrl: 'https://ntlmothsjvhdvcykcvex.supabase.co/storage/v1/object/public/inverters',
            storageKey: 'solarParams_v5'
        };

        // 欄位對照表（繁體中文-英文）
        const FieldMap = {
            // 逆變器欄位
            model_name: { zh: '型號', en: 'Model Name', icon: 'fa-tag' },
            rated_output_power_kw: { zh: '額定輸出功率', en: 'Rated Output Power', unit: 'kW', icon: 'fa-bolt' },
            max_input_voltage_v: { zh: '最大輸入電壓', en: 'Max Input Voltage', unit: 'V', icon: 'fa-arrow-up' },
            rated_input_voltage_v: { zh: '額定輸入電壓', en: 'Rated Input Voltage', unit: 'V', icon: 'fa-plug' },
            num_mpp_trackers: { zh: 'MPPT 組數', en: 'Number of MPPT Trackers', icon: 'fa-sitemap' },
            mppt_voltage_range_v: { zh: 'MPPT 電壓追蹤範圍', en: 'MPPT Voltage Range', unit: 'V', icon: 'fa-gauge' },
            max_input_current_per_mppt_a: { zh: '每組 MPPT 最大輸入電流', en: 'Max Input Current per MPPT', unit: 'A', icon: 'fa-plug' },
            max_input_current_total_a: { zh: '總最大輸入電流', en: 'Max Input Current Total', unit: 'A', icon: 'fa-plug' },
            output_voltage_range_v: { zh: '輸出電壓範圍', en: 'Output Voltage Range', unit: 'V', icon: 'fa-bolt' },
            nominal_output_voltage_v: { zh: '額定輸出電壓', en: 'Nominal Output Voltage', unit: 'V', icon: 'fa-bolt' },
            max_output_current_a: { zh: '最大輸出電流', en: 'Max Output Current', unit: 'A', icon: 'fa-plug' },
            rated_output_frequency_hz: { zh: '額定頻率', en: 'Rated Frequency', unit: 'Hz', icon: 'fa-wave-square' },
            output_power_factor: { zh: '功率因數', en: 'Power Factor', icon: 'fa-chart-line' },
            operating_temperature_range_c: { zh: '工作溫度範圍', en: 'Operating Temperature', unit: '°C', icon: 'fa-thermometer-half' },
            cooling_method: { zh: '冷卻方式', en: 'Cooling Method', icon: 'fa-fan' },
            protection_degree: { zh: '防護等級', en: 'Protection Degree', icon: 'fa-shield-alt' },
            communication_interface: { zh: '通訊介面', en: 'Communication Interface', icon: 'fa-network-wired' },
            max_efficiency_percent: { zh: '最高效率', en: 'Max Efficiency', unit: '%', icon: 'fa-chart-line' },
            manufacturer: { zh: '製造商', en: 'Manufacturer', icon: 'fa-industry' },
            series: { zh: '系列名稱', en: 'Series', icon: 'fa-layer-group' },
            // 模組欄位
            model_number: { zh: '模組型號', en: 'Module Model Number', icon: 'fa-tag' },
            p_max: { zh: '最大功率', en: 'Maximum Power', unit: 'W', icon: 'fa-sun' },
            v_oc: { zh: '開路電壓', en: 'Open Circuit Voltage', unit: 'V', icon: 'fa-bolt' },
            i_sc: { zh: '短路電流', en: 'Short Circuit Current', unit: 'A', icon: 'fa-burst' },
            v_mp: { zh: '最大功率點電壓', en: 'Voltage at Max Power', unit: 'V', icon: 'fa-chart-line' },
            i_mp: { zh: '最大功率點電流', en: 'Current at Max Power', unit: 'A', icon: 'fa-chart-line' },
            cell_type: { zh: '電池類型', en: 'Cell Type', icon: 'fa-microchip' },
            dimensions_mm: { zh: '尺寸', en: 'Dimensions', unit: 'mm', icon: 'fa-ruler' },
            weight_kg: { zh: '重量', en: 'Weight', unit: 'kg', icon: 'fa-weight' }
        };

        const App = {
            db: null,
            cache: { 
                inverters: [], modules: [], impedance: [], 
                ampPVC: [], ampMetal60: [], ampMetal75: [], ampMetal90: [], 
                conduit: [], conduitFlexNonMetal: [], conduitThickMetal: [], conduitThinMetal: [], 
                inverterImages: [],
                groundTypes: [], groundingConductorWireSizing: [], breakerStandards: []
            },
            reportData: { params: {}, vd: [], sc: [], planning: [] },
            roofs: [],
            auth: {
                visitorId: null,
                isReady: false,
                fpLoadPromise: null,

                init: async () => {
                    App.auth.showApp(false);
                    App.auth.showLogin(true);
                    App.auth.bindForm();

                    try {
                        await App.auth.ensureDb();
                        await App.auth.ensureFingerprint();
                        App.auth.isReady = true;
                        App.auth.setMsg('', false);
                    } catch (e) {
                        console.error('Auth init failed:', e);
                        App.auth.setMsg(`初始化失敗：${e?.message || e}`, true);
                    }
                },

                bindForm: () => {
                    const form = document.getElementById('loginForm');
                    if (!form || form.hasAttribute('data-bound')) return;
                    form.addEventListener('submit', (e) => {
                        e.preventDefault();
                        App.auth.verify();
                    });
                    form.setAttribute('data-bound', 'true');
                },

                ensureDb: async () => {
                    if (App.db) return App.db;
                    if (typeof supabase === 'undefined' || !supabase?.createClient) {
                        throw new Error('Supabase SDK 未載入（請檢查 CDN）');
                    }
                    const { createClient } = supabase;
                    App.db = createClient(CONFIG.supabaseUrl, CONFIG.supabaseKey, {
                        auth: { persistSession: false },
                        db: { schema: 'public' },
                        global: { headers: { apikey: CONFIG.supabaseKey } }
                    });
                    return App.db;
                },

                ensureFingerprint: async () => {
                    if (App.auth.visitorId) return App.auth.visitorId;
                    await App.auth.ensureFingerprintLibReady();
                    const fp = await FingerprintJS.load(); // 確保先完成 load() 檢查
                    const res = await fp.get();
                    App.auth.visitorId = res?.visitorId || null;
                    if (!App.auth.visitorId) throw new Error('無法取得設備指紋 visitorId');
                    return App.auth.visitorId;
                },

                // 確保 FingerprintJS 已載入並可用（含 CDN 載入較慢時的等待）
                ensureFingerprintLibReady: async () => {
                    if (typeof FingerprintJS !== 'undefined' && FingerprintJS?.load) return;
                    if (App.auth.fpLoadPromise) return App.auth.fpLoadPromise;

                    App.auth.fpLoadPromise = new Promise((resolve, reject) => {
                        // 若 head 內 script 尚未載入完成，做輪詢等待
                        const start = Date.now();
                        const timeoutMs = 6000;
                        const tick = () => {
                            if (typeof FingerprintJS !== 'undefined' && FingerprintJS?.load) {
                                resolve();
                                return;
                            }
                            if (Date.now() - start > timeoutMs) {
                                // 若 head script 因網路/CSP/阻擋未生效：依序嘗試多個 CDN
                                const tryLoad = (src) => new Promise((res, rej) => {
                                    const s = document.createElement('script');
                                    s.src = src;
                                    s.async = true;
                                    s.onload = () => res(true);
                                    s.onerror = () => rej(new Error(`FingerprintJS CDN 載入失敗：${src}`));
                                    document.head.appendChild(s);
                                });

                                (async () => {
                                    try {
                                        // 1) OpenFP CDN IIFE
                                        await tryLoad('https://openfpcdn.io/fingerprintjs/v4/iife.js');
                                        if (typeof FingerprintJS !== 'undefined' && FingerprintJS?.load) { resolve(); return; }
                                    } catch (_) {}
                                    try {
                                        // 2) jsDelivr 官方套件（IIFE/UMD 也會掛到 window.FingerprintJS）
                                        await tryLoad('https://cdn.jsdelivr.net/npm/@fingerprintjs/fingerprintjs@4/dist/fp.min.js');
                                        if (typeof FingerprintJS !== 'undefined' && FingerprintJS?.load) { resolve(); return; }
                                    } catch (e) {
                                        reject(e);
                                        return;
                                    }
                                    reject(new Error('FingerprintJS 已載入但未提供 FingerprintJS.load（可能被 CSP 攔截或 CDN 回應異常）'));
                                })();
                                return;
                            }
                            setTimeout(tick, 100);
                        };
                        tick();
                    });

                    return App.auth.fpLoadPromise;
                },

                setLoading: (loading) => {
                    const btn = document.getElementById('loginBtn');
                    const inp = document.getElementById('passcodeInput');
                    if (btn) btn.disabled = !!loading;
                    if (inp) inp.disabled = !!loading;
                    if (btn) btn.innerHTML = loading ? '<i class="fa-solid fa-spinner fa-spin mr-2"></i>驗證中...' : '驗證並登入';
                },

                setMsg: (msg, isError) => {
                    const el = document.getElementById('loginMsg');
                    if (!el) return;
                    if (!msg) {
                        el.classList.add('hidden');
                        el.textContent = '';
                        return;
                    }
                    el.textContent = msg;
                    el.classList.remove('hidden');
                    el.classList.toggle('text-red-600', !!isError);
                    el.classList.toggle('text-green-600', !isError);
                },

                showLogin: (show) => {
                    const el = document.getElementById('loginScreen');
                    if (!el) return;
                    el.classList.toggle('hidden', !show);
                },

                showApp: (show) => {
                    const el = document.getElementById('appRoot');
                    if (!el) return;
                    el.classList.toggle('hidden', !show);
                },

                // verifyAccess：先等 FingerprintJS 就緒，再做 Supabase 查詢
                verifyAccess: async () => {
                    const passcode = String(document.getElementById('passcodeInput')?.value || '').trim();
                    if (!passcode) {
                        App.auth.setMsg('請輸入通行碼', true);
                        return;
                    }

                    App.auth.setLoading(true);
                    App.auth.setMsg('', false);

                    try {
                        // 先確保 FingerprintJS 可用並取得設備指紋，再進行 Supabase 查詢
                        const visitorId = await App.auth.ensureFingerprint();
                        await App.auth.ensureDb();

                        // 依 passcode 讀取 access_control
                        const { data, error } = await App.db
                            .from('access_control')
                            .select('passcode,bound_device_id,is_used')
                            .eq('passcode', passcode)
                            .maybeSingle();

                        if (error) {
                            const code = error?.code ? ` (${error.code})` : '';
                            throw new Error(`查詢失敗${code}：${error?.message || error}`);
                        }
                        if (!data) {
                            App.auth.setMsg('通行碼不存在或輸入錯誤', true);
                            return;
                        }

                        const isUsed = !!data.is_used;
                        const bound = String(data.bound_device_id || '');

                        if (!isUsed) {
                            // 首次登入：寫入 bound_device_id 並設定 is_used
                            const { error: upErr } = await App.db
                                .from('access_control')
                                .update({ bound_device_id: visitorId, is_used: true })
                                .eq('passcode', passcode)
                                .eq('is_used', false);

                            if (upErr) {
                                const code = upErr?.code ? ` (${upErr.code})` : '';
                                throw new Error(`更新失敗${code}：${upErr?.message || upErr}`);
                            }
                        } else {
                            // 回訪：比對 bound_device_id
                            if (!bound || bound !== visitorId) {
                                App.auth.setMsg('此碼已在其他裝置綁定', true);
                                return;
                            }
                        }

                        // 登入成功：顯示主畫面並初始化系統
                        App.auth.showLogin(false);
                        App.auth.showApp(true);
                        await App.init();
                    } catch (e) {
                        console.error('Login verify error:', e);
                        App.auth.setMsg(`登入失敗：${e?.message || e}`, true);
                    } finally {
                        App.auth.setLoading(false);
                    }
                },

                // 相容舊呼叫點
                verify: async () => App.auth.verifyAccess()
            },

            init: async () => {
                // 檢查 Supabase 庫是否已載入
                if (typeof supabase === 'undefined' || !supabase) {
                    console.error('Supabase 庫未載入，請檢查網路連接或 CDN 是否可用');
                    const statusEl = document.getElementById('dbStatus');
                    if (statusEl) {
                        statusEl.innerHTML = '<span class="text-red-500"><i class="fa-solid fa-exclamation-triangle"></i> Supabase 庫未載入</span>';
                        statusEl.classList.add('bg-red-50', 'border-red-200');
                    }
                    // 即使沒有資料庫，也初始化 UI（使用空資料）
                    App.ui.initDOM();
                    App.actions.loadState();
                    return;
                }
                
                try {
                    // 若尚未建立 client，這裡建立
                    if (!App.db) {
                        const { createClient } = supabase;
                        App.db = createClient(CONFIG.supabaseUrl, CONFIG.supabaseKey, {
                        auth: {
                            persistSession: false
                        },
                        db: {
                            schema: 'public'
                        },
                        global: {
                            headers: {
                                'apikey': CONFIG.supabaseKey
                            }
                        }
                        });
                    }
                    await App.data.fetchAll();
                } catch (err) {
                    console.error('初始化資料庫連接失敗:', err);
                    const statusEl = document.getElementById('dbStatus');
                    if (statusEl) {
                        statusEl.innerHTML = `<span class="text-red-500"><i class="fa-solid fa-exclamation-triangle"></i> 連接失敗: ${err.message || '未知錯誤'}</span>`;
                        statusEl.classList.add('bg-red-50', 'border-red-200');
                    }
                }
                
                App.ui.initDOM();
                App.actions.loadState();
                // 初始化時執行一次計算
                App.calc.runDebounced();
            },

            data: {
                fetchAll: async () => {
                    const statusEl = document.getElementById('dbStatus');
                    
                    // 檢查資料庫連接是否已初始化
                    if (!App.db) {
                        statusEl.innerHTML = '<span class="text-red-500"><i class="fa-solid fa-exclamation-triangle"></i> 資料庫未初始化</span>';
                        statusEl.classList.add('bg-red-50', 'border-red-200');
                        console.error('資料庫連接未初始化');
                        return;
                    }
                    
                    statusEl.innerHTML = '<span class="text-yellow-600"><i class="fa-solid fa-spinner fa-spin"></i> 連接資料庫中...</span>';
                    statusEl.classList.remove('bg-green-50', 'border-green-200', 'bg-red-50', 'border-red-200');
                    statusEl.classList.add('bg-yellow-50', 'border-yellow-200');
                    
                    try {
                        // 先測試連接（添加超時處理）
                        const testQueryPromise = App.db.from('delta_inverters').select('id').limit(1);
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('連接超時（超過10秒）')), 10000)
                        );
                        
                        const testQuery = await Promise.race([testQueryPromise, timeoutPromise]);
                        
                        if (testQuery.error) {
                            const errorCode = testQuery.error.code || '';
                            const errorMessage = testQuery.error.message || '未知錯誤';
                            
                            // 根據錯誤代碼提供更友好的提示
                            let friendlyMsg = errorMessage;
                            if (errorCode === 'PGRST116' || errorMessage.includes('relation') || errorMessage.includes('does not exist')) {
                                friendlyMsg = '資料表不存在，請檢查資料庫結構';
                            } else if (errorCode === '42501' || errorMessage.includes('permission') || errorMessage.includes('權限')) {
                                friendlyMsg = '權限不足，請檢查 API Key 是否正確';
                            } else if (errorMessage.includes('network') || errorMessage.includes('fetch')) {
                                friendlyMsg = '網路連接失敗，請檢查網路或防火牆設定';
                            } else if (errorMessage.includes('timeout')) {
                                friendlyMsg = '連接超時，請檢查網路速度或 Supabase 服務狀態';
                            }
                            
                            throw new Error(`資料庫連接失敗: ${friendlyMsg} (${errorCode || '無錯誤代碼'})`);
                        }
                        
                        // 先查詢主要資料表（使用 Promise.allSettled 以獲取每個查詢的詳細錯誤）
                        const results = await Promise.allSettled([
                            App.db.from('delta_inverters').select('*').order('rated_output_power_kw', {ascending:false}),
                            App.db.from('solar_modules').select('*').order('manufacturer'),
                            App.db.from('cable_impedance_25c').select('*'), 
                            App.db.from('ampacity_pvc_60c').select('*'),    
                            App.db.from('ampacity_metal_60c').select('*'),  
                            App.db.from('ampacity_metal_75c').select('*'),  
                            App.db.from('conduit_sizing_non_metallic').select('*'), 
                            App.db.from('inverter_images').select('*'),
                            App.db.from('ampacity_metal_90c').select('*')
                        ]);
                        
                        // 檢查每個查詢的結果
                        const tableNames = ['delta_inverters', 'solar_modules', 'cable_impedance_25c', 'ampacity_pvc_60c', 
                                          'ampacity_metal_60c', 'ampacity_metal_75c', 'conduit_sizing_non_metallic', 
                                          'inverter_images', 'ampacity_metal_90c'];
                        const errors = [];
                        
                        results.forEach((result, index) => {
                            if (result.status === 'rejected') {
                                errors.push(`${tableNames[index]}: ${result.reason?.message || result.reason || '查詢失敗'}`);
                            } else if (result.value.error) {
                                errors.push(`${tableNames[index]}: ${result.value.error.message || result.value.error.code || '查詢失敗'}`);
                            }
                        });
                        
                        if (errors.length > 0) {
                            console.error('部分資料表查詢失敗:', errors);
                        }
                        
                        // 提取成功的查詢結果
                        const inv = results[0].status === 'fulfilled' && !results[0].value.error ? results[0].value : {data: []};
                        const mod = results[1].status === 'fulfilled' && !results[1].value.error ? results[1].value : {data: []};
                        const imp = results[2].status === 'fulfilled' && !results[2].value.error ? results[2].value : {data: []};
                        const pvc = results[3].status === 'fulfilled' && !results[3].value.error ? results[3].value : {data: []};
                        const m60 = results[4].status === 'fulfilled' && !results[4].value.error ? results[4].value : {data: []};
                        const m75 = results[5].status === 'fulfilled' && !results[5].value.error ? results[5].value : {data: []};
                        const pipe = results[6].status === 'fulfilled' && !results[6].value.error ? results[6].value : {data: []};
                        const img = results[7].status === 'fulfilled' && !results[7].value.error ? results[7].value : {data: []};
                        const m90 = results[8].status === 'fulfilled' && !results[8].value.error ? results[8].value : {data: []};
                        
                        // 單獨查詢所有管徑資料表（如果表不存在不會影響其他查詢）
                        let pipeFlexNonMetal = {data: []};
                        let pipeThickMetal = {data: []};
                        let pipeThinMetal = {data: []};
                        
                        try {
                            const result = await App.db.from('conduit_sizing_flex_non_metallic').select('*');
                            if (!result.error) {
                                pipeFlexNonMetal = result;
                            } else {
                                console.warn('非金屬軟管資料表查詢失敗:', result.error);
                            }
                        } catch (err) {
                            console.warn('非金屬軟管資料表不存在或查詢失敗，使用空資料:', err);
                        }
                        
                        try {
                            const result = await App.db.from('conduit_sizing_thick_metal').select('*');
                            if (!result.error) {
                                pipeThickMetal = result;
                            } else {
                                console.warn('金屬厚管資料表查詢失敗:', result.error);
                            }
                        } catch (err) {
                            console.warn('金屬厚管資料表不存在或查詢失敗，使用空資料:', err);
                        }
                        
                        try {
                            const result = await App.db.from('conduit_sizing_thin_metal').select('*');
                            if (!result.error) {
                                pipeThinMetal = result;
                            } else {
                                console.warn('金屬薄管資料表查詢失敗:', result.error);
                            }
                        } catch (err) {
                            console.warn('金屬薄管資料表不存在或查詢失敗，使用空資料:', err);
                        }
                        
                        // --- 追加：接地/斷路器標準（可選資料表，不影響主流程） ---
                        const fetchOptionalByCandidates = async (candidates, label) => {
                            for (const table of candidates) {
                                try {
                                    const r = await App.db.from(table).select('*');
                                    if (!r?.error) {
                                        console.log(`${label} 載入成功: ${table} (${(r.data || []).length}筆)`);
                                        return r;
                                    }
                                    console.warn(`${label} 查詢失敗(${table}):`, r.error);
                                } catch (e) {
                                    console.warn(`${label} 資料表不存在或查詢失敗(${table}):`, e);
                                }
                            }
                            return { data: [] };
                        };
                        
                        const groundTypes = await fetchOptionalByCandidates(
                            ['grounding_types', 'ground_types', 'ground_type', 'earthing_types', 'earthing_type', '接地種類'],
                            '接地種類'
                        );
                        const groundingConductorWireSizing = await fetchOptionalByCandidates(
                            // 接地導線線徑
                            ['grounding_wire_sizing', 'grounding_conductor_wire_sizing', 'grounding_conductor_sizing', 'grounding_wire_sizes', 'ground_wire_sizes', 'earthing_wire_sizes', '接地導線線徑'],
                            '接地導線線徑'
                        );
                        const breakerStandards = await fetchOptionalByCandidates(
                            // 指定：對應到 Supabase Breaker Standards table
                            ['Breaker Standards', 'breaker_standards', 'breaker_standard', 'breaker_standard_table', 'breakerStandards', 'breaker', 'breaker_specs'],
                            '斷路器標準'
                        );
                        
                        App.cache = { 
                            inverters: inv.data||[], 
                            modules: mod.data||[], 
                            impedance: imp.data||[], 
                            ampPVC: pvc.data||[], 
                            ampMetal60: m60.data||[], 
                            ampMetal75: m75.data||[], 
                            ampMetal90: m90.data||[], 
                            conduit: pipe.data||[], 
                            conduitFlexNonMetal: pipeFlexNonMetal.data||[], 
                            conduitThickMetal: pipeThickMetal.data||[], 
                            conduitThinMetal: pipeThinMetal.data||[], 
                            inverterImages: img.data||[],
                            groundTypes: groundTypes.data || [],
                            groundingConductorWireSizing: groundingConductorWireSizing.data || [],
                            breakerStandards: breakerStandards.data || []
                        };
                        
                        // 檢查是否有關鍵資料
                        const hasCriticalData = (inv.data && inv.data.length > 0) || (mod.data && mod.data.length > 0);
                        
                        if (errors.length > 0 && !hasCriticalData) {
                            // 如果關鍵資料表都失敗，顯示錯誤
                            const errorMsg = errors.slice(0, 3).join(', ') + (errors.length > 3 ? '...' : '');
                            statusEl.innerHTML = `<span class="text-red-500"><i class="fa-solid fa-exclamation-triangle"></i> 連線失敗: ${errorMsg}</span>`;
                            statusEl.classList.remove('bg-yellow-50', 'border-yellow-200');
                            statusEl.classList.add('bg-red-50', 'border-red-200');
                            console.error('資料庫載入錯誤:', errors);
                        } else {
                            // 部分成功或全部成功
                            const warningMsg = errors.length > 0 ? ` (${errors.length}個資料表失敗)` : '';
                            statusEl.innerHTML = `<span class="text-green-600 font-bold"><i class="fa-solid fa-check-circle"></i> 資料庫就緒${warningMsg}</span>`;
                            statusEl.classList.remove('bg-yellow-50', 'border-yellow-200', 'bg-red-50', 'border-red-200');
                        statusEl.classList.add('bg-green-50', 'border-green-200');
                            
                        // 資料載入完成後重新初始化 UI
                        App.ui.populateSelects();
                        App.ui.renderTables();
                        }
                    } catch (err) { 
                        const errorMsg = err.message || err.toString() || '未知錯誤';
                        statusEl.innerHTML = `<span class="text-red-500"><i class="fa-solid fa-exclamation-triangle"></i> 連線失敗: ${errorMsg}</span>`;
                        statusEl.classList.remove('bg-yellow-50', 'border-yellow-200');
                        statusEl.classList.add('bg-red-50', 'border-red-200');
                        console.error('資料庫載入錯誤:', err);
                        
                        // 顯示詳細錯誤資訊
                        if (err.message) {
                            console.error('錯誤詳情:', {
                                message: err.message,
                                stack: err.stack,
                                config: {
                                    url: CONFIG.supabaseUrl,
                                    hasKey: !!CONFIG.supabaseKey
                                }
                            });
                        }
                    }
                }
            },

            ui: {
                initDOM: () => {
                    App.ui.populateSelects();
                    App.ui.renderTables(); 
                    // 為所有 .inp-param 元素添加事件監聽器
                    document.querySelectorAll('.inp-param').forEach(el => {
                        el.addEventListener('input', App.calc.runDebounced);
                        el.addEventListener('change', App.calc.runDebounced);
                    });
                    // 為模組選擇添加事件監聽
                    const moduleSelect = document.getElementById('activeModuleSelect');
                    const panelsInput = document.getElementById('plannedPanels');
                    
                    // 更新容量的函數
                    const updateCapacity = () => {
                        const modIdx = moduleSelect ? moduleSelect.value : '';
                        const panels = panelsInput ? parseFloat(panelsInput.value || 0) : 0;
                        const capEl = document.getElementById('capacityValue');
                        
                        if (modIdx !== "" && panels > 0) {
                            const mod = App.cache.modules[modIdx];
                            if (mod && capEl) {
                                const capacity = (panels * mod.p_max) / 1000;
                                capEl.textContent = capacity.toFixed(2) + ' kW';
                            }
                        } else if (capEl) {
                            capEl.textContent = '0.00 kW';
                        }
                    };
                    
                    if (moduleSelect) {
                        moduleSelect.addEventListener('change', () => {
                            App.calc.runDebounced();
                            updateCapacity();
                            // 更新模組規格顯示
                            const modIdx = moduleSelect.value;
                            if (modIdx !== "") {
                                const mod = App.cache.modules[modIdx];
                                if (mod) {
                                    document.getElementById('moduleSpecsDisplay').innerHTML = 
                                        `Voc: ${mod.v_oc}V | Vmp: ${mod.v_mp || mod.v_oc * 0.85}V | Isc: ${mod.i_sc}A | Pmax: ${mod.p_max}W`;
                                }
                            } else {
                                document.getElementById('moduleSpecsDisplay').innerHTML = '';
                            }
                        });
                    }
                    
                    if (panelsInput) {
                        panelsInput.addEventListener('input', () => {
                            updateCapacity();
                            App.calc.runDebounced();
                        });
                    }
                    document.getElementById('hasTransformer')?.addEventListener('change', (e) => {
                        document.getElementById('transSection').classList.toggle('hidden', !e.target.checked);
                        App.calc.runDebounced();
                    });
                    // 使用 MutationObserver 監聽動態添加的元素
                    const observer = new MutationObserver((mutations) => {
                        mutations.forEach((mutation) => {
                            mutation.addedNodes.forEach((node) => {
                                if (node.nodeType === 1) { // Element node
                                    // 為新添加的元素添加事件監聽
                                    if (node.classList && node.classList.contains('inp-param')) {
                                        node.addEventListener('input', App.calc.runDebounced);
                                        node.addEventListener('change', App.calc.runDebounced);
                                    }
                                    // 檢查子元素
                                    const newInputs = node.querySelectorAll && node.querySelectorAll('.inp-param');
                                    if (newInputs) {
                                        newInputs.forEach(el => {
                                            el.addEventListener('input', App.calc.runDebounced);
                                            el.addEventListener('change', App.calc.runDebounced);
                                        });
                                    }
                                }
                            });
                        });
                    });
                    // 屋頂清單 UI（在 plannedPanels 的監聽器建立後再初始化，確保同步時可更新容量與計算）
                    App.ui.initRoofs();
                    observer.observe(document.body, { childList: true, subtree: true });
                },

                // --- 屋頂清單 (可新增/刪除 + 每屋頂規劃片數) ---
                initRoofs: () => {
                    // 初始化資料（若尚未有 roofs）
                    if (!Array.isArray(App.roofs) || App.roofs.length === 0) {
                        App.roofs = [{ id: Date.now(), name: '屋頂 1', panels: 0 }];
                    }

                    // 綁定新增按鈕（只綁一次）
                    const addBtn = document.getElementById('addRoofBtn');
                    if (addBtn && !addBtn.hasAttribute('data-listener-added')) {
                        addBtn.addEventListener('click', () => App.ui.addRoof());
                        addBtn.setAttribute('data-listener-added', 'true');
                    }

                    // 綁定清單事件（事件委派，只綁一次）
                    const list = document.getElementById('roofList');
                    if (list && !list.hasAttribute('data-listener-added')) {
                        list.addEventListener('input', (e) => {
                            const t = e.target;
                            if (!t || !t.getAttribute) return;

                            // 更新屋頂名稱
                            const nameId = t.getAttribute('data-roof-name');
                            if (nameId) {
                                const r = (App.roofs || []).find(x => String(x.id) === String(nameId));
                                if (r) r.name = String(t.value || '').trim() || r.name || '屋頂';
                                // 名稱只影響顯示，仍觸發一次計算刷新
                                App.calc.runDebounced();
                                return;
                            }

                            // 更新屋頂片數並同步到總片數
                            const panelsId = t.getAttribute('data-roof-panels');
                            if (panelsId) {
                                const r = (App.roofs || []).find(x => String(x.id) === String(panelsId));
                                if (r) {
                                    let v = parseInt(t.value || 0);
                                    if (isNaN(v) || v < 0) v = 0;
                                    r.panels = v;
                                }
                                App.ui.syncPlannedPanelsFromRoofs();
                                return;
                            }
                        });

                        list.addEventListener('click', (e) => {
                            const btn = e.target?.closest?.('button[data-roof-del]');
                            if (btn) {
                                const id = btn.getAttribute('data-roof-del');
                                App.ui.removeRoof(id);
                            }
                        });

                        list.setAttribute('data-listener-added', 'true');
                    }

                    App.ui.renderRoofs();
                    App.ui.syncPlannedPanelsFromRoofs();
                },

                renderRoofs: () => {
                    const list = document.getElementById('roofList');
                    if (!list) return;

                    if (!Array.isArray(App.roofs) || App.roofs.length === 0) {
                        App.roofs = [{ id: Date.now(), name: '屋頂 1', panels: 0 }];
                    }

                    const esc = (s) => String(s ?? '')
                        .replace(/&/g, '&amp;')
                        .replace(/"/g, '&quot;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');

                    list.innerHTML = (App.roofs || []).map((r, idx) => {
                        const roofName = (r && r.name) ? String(r.name) : `屋頂 ${idx + 1}`;
                        const roofPanels = (r && typeof r.panels !== 'undefined') ? r.panels : 0;
                        const canDelete = (App.roofs || []).length > 1;
                        return `
                            <div class="flex items-center gap-2 bg-white border border-gray-200 rounded-lg p-2 shadow-sm">
                                <div class="text-xs font-bold text-slate-600 w-14 flex-shrink-0 text-center bg-slate-100 rounded py-1">屋頂</div>
                                <input type="text" class="inp-param flex-grow border border-gray-200 rounded-md px-2 py-1.5 text-xs bg-gray-50 focus:bg-white" value="${esc(roofName)}" data-roof-name="${r.id}" placeholder="屋頂名稱">
                                <div class="flex items-center gap-1 flex-shrink-0">
                                    <input type="number" min="0" class="inp-param w-24 border border-gray-200 rounded-md px-2 py-1.5 text-xs text-blue-700 font-bold bg-gray-50 focus:bg-white text-right" value="${roofPanels}" data-roof-panels="${r.id}">
                                    <span class="text-xs text-gray-400 font-bold">片</span>
                                </div>
                                <button type="button" class="${canDelete ? 'text-red-400 hover:text-red-600' : 'text-gray-200 cursor-not-allowed'} px-2" ${canDelete ? `data-roof-del="${r.id}"` : 'disabled'}>
                                    <i class="fa-solid fa-trash-can"></i>
                                </button>
                            </div>
                        `;
                    }).join('');
                },

                addRoof: () => {
                    if (!Array.isArray(App.roofs)) App.roofs = [];
                    const nextIdx = App.roofs.length + 1;
                    const id = Date.now() + Math.floor(Math.random() * 1000);
                    App.roofs.push({ id, name: `屋頂 ${nextIdx}`, panels: 0 });
                    App.ui.renderRoofs();
                    App.ui.syncPlannedPanelsFromRoofs();
                },

                removeRoof: (id) => {
                    if (!Array.isArray(App.roofs)) App.roofs = [{ id: Date.now(), name: '屋頂 1', panels: 0 }];
                    if (App.roofs.length <= 1) return; // 至少保留 1 個
                    App.roofs = App.roofs.filter(r => String(r.id) !== String(id));
                    App.ui.renderRoofs();
                    App.ui.syncPlannedPanelsFromRoofs();
                },

                syncPlannedPanelsFromRoofs: () => {
                    const panelsInput = document.getElementById('plannedPanels');
                    if (!panelsInput) return;
                    const total = (Array.isArray(App.roofs) ? App.roofs : []).reduce((sum, r) => {
                        const v = parseInt(r?.panels || 0);
                        return sum + (isNaN(v) ? 0 : v);
                    }, 0);
                    panelsInput.value = String(total);
                    // 觸發既有監聽（容量顯示 & 自動計算）
                    panelsInput.dispatchEvent(new Event('input', { bubbles: true }));
                },

                getRoofList: () => {
                    if (Array.isArray(App.roofs) && App.roofs.length > 0) return App.roofs;
                    return [{ id: 1, name: '屋頂 1', panels: parseInt(document.getElementById('plannedPanels')?.value || 0) || 0 }];
                },
                populateSelects: () => {
                    // Cable
                    let opts = '<option value="">請選擇線徑...</option>';
                    App.cache.impedance.forEach((c, i) => { 
                        if(c.insulation_type === 'XLPE' || c.insulation_type === 'PVC') 
                            opts += `<option value="${i}">${c.insulation_type} ${c.wire_size_label} (${c.total_area_mm2}mm²)</option>`; 
                    });
                    ['cableSelect1', 'cableSelect2', 'cableSelect3'].forEach(id => { 
                        const el = document.getElementById(id); 
                        if(el) {
                            el.innerHTML = opts;
                            // 確保事件監聽器已添加
                            if (!el.hasAttribute('data-listener-added')) {
                                el.addEventListener('change', App.calc.runDebounced);
                                el.setAttribute('data-listener-added', 'true');
                            }
                        }
                    });
                    
                    // Module
                    let mOpts = '<option value="">請選擇模組...</option>';
                    App.cache.modules.forEach((m, i) => { 
                        mOpts += `<option value="${i}">${m.manufacturer} ${m.model_number} (${m.p_max}W)</option>`; 
                    });
                    const moduleSelect = document.getElementById('activeModuleSelect');
                    if (moduleSelect) {
                        moduleSelect.innerHTML = mOpts;
                    }
                },
                switchTab: (id) => {
                    document.querySelectorAll('.tab-content').forEach(e => e.classList.remove('active'));
                    document.querySelectorAll('.tab-btn').forEach(e => e.classList.remove('active'));
                    document.getElementById(`tab-${id}`).classList.add('active');
                    const map = {'planning':0, 'inverters':1, 'modules':2, 'cables':3};
                    document.querySelectorAll('.tab-btn')[map[id]]?.classList.add('active');
                },
                
                // --- 逆變器配置區 ---
                addInverterRow: () => {
                    const tb = document.getElementById('inverterListBody');
                    const rid = Date.now();
                    let ops = '<option value="">請選擇型號...</option>';
                    App.cache.inverters.forEach((i, x) => ops += `<option value="${x}">${i.model_name} (${i.rated_output_power_kw}kW)</option>`);
                    
                    const tr = document.createElement('tr');
                    tr.id = `row-${rid}`;
                    tr.className = "hover:bg-gray-50 transition align-top";
                    tr.innerHTML = `
                        <td class="p-2">
                            <select class="inp-param border border-gray-300 w-full p-2 text-sm rounded mb-1" onchange="App.ui.updateInvRow(${rid},this)">${ops}</select>
                            <div id="spec-${rid}" class="text-xs text-slate-500 bg-slate-50 p-2 rounded border border-slate-100 hidden grid grid-cols-2 gap-x-2 gap-y-1"></div>
                        </td>
                        <td class="p-2"><input type="number" value="100" min="50" max="200" class="inp-param border border-gray-300 w-full text-center rounded p-2 text-blue-600 font-bold" placeholder="%" oninput="App.calc.runDebounced()"></td>
                        <td class="p-2"><input type="number" value="1" min="1" class="inp-param border border-gray-300 w-full text-center rounded p-2" oninput="App.ui.calcInvTotal();App.calc.runDebounced()"></td>
                        <td class="text-center pt-3"><button onclick="document.getElementById('row-${rid}').remove();App.ui.calcInvTotal();App.calc.runDebounced()" class="text-red-400 hover:text-red-600"><i class="fa-solid fa-trash-can"></i></button></td>
                    `;
                    tb.appendChild(tr);
                    // 為新添加的元素添加事件監聽
                    tr.querySelectorAll('.inp-param').forEach(el => {
                        el.addEventListener('input', App.calc.runDebounced);
                        el.addEventListener('change', App.calc.runDebounced);
                    });
                },
                updateInvRow: (rid, sel) => {
                    if(!sel.value) {
                        const specDiv = document.getElementById(`spec-${rid}`);
                        if(specDiv) specDiv.classList.add('hidden');
                        return;
                    }
                    const inv = App.cache.inverters[sel.value];
                    const specDiv = document.getElementById(`spec-${rid}`);
                    specDiv.classList.remove('hidden');
                    specDiv.innerHTML = `
                        <div class="col-span-2 text-xs font-bold text-slate-700 mb-1 pb-1 border-b border-slate-200">${inv.model_name} 規格</div>
                        <div><i class="fa-solid fa-bolt text-amber-500 mr-1"></i><span class="font-semibold">MPPT數量:</span> ${inv.num_mpp_trackers}組</div>
                        <div><i class="fa-solid fa-gauge text-blue-500 mr-1"></i><span class="font-semibold">MPPT電壓範圍:</span> ${inv.mppt_voltage_range_v ? (String(inv.mppt_voltage_range_v).includes('NaN') ? '資料錯誤' : inv.mppt_voltage_range_v) : 'N/A'}V</div>
                        <div><i class="fa-solid fa-plug text-green-500 mr-1"></i><span class="font-semibold">MPPT最大電流:</span> ${(() => {
                            const mpptCount = parseInt(inv.num_mpp_trackers || 0) || 0;
                            const isM125HV = /m125hv/i.test(String(inv.model_name || '')) || /m125hv/i.test(String(inv.series || ''));
                            const parseCurrent = (value, maxAllowed) => {
                                if (value === null || value === undefined || value === '') return null;
                                if (typeof value === 'number') return (!isNaN(value) && value > 0 && value <= maxAllowed) ? value : null;
                                const s = String(value).trim();
                                if (s.includes('999') || s.toLowerCase().includes('na') || s.toLowerCase().includes('n/a')) return null;
                                const m = s.match(/^[\d.]+/);
                                if (!m) return null;
                                const num = parseFloat(m[0]);
                                return (!isNaN(num) && num > 0 && num <= maxAllowed) ? num : null;
                            };
                            
                            const totalCurrentField = inv.max_input_current_total_a || inv.max_input_current_total ||
                                                     inv['Max Input Current Total A'] || inv['max_input_current_total_a'];
                            const totalCurrent = parseCurrent(totalCurrentField, 1000);
                            const perMppt = parseCurrent(inv.max_input_current_per_mppt_a, 100);
                            
                            let perMpptFinal = null;
                            if (mpptCount <= 1) {
                                perMpptFinal = perMppt !== null ? perMppt : totalCurrent;
                            } else {
                                if (!isM125HV && perMppt !== null) perMpptFinal = perMppt;
                                else if (totalCurrent !== null) perMpptFinal = totalCurrent / mpptCount;
                                else perMpptFinal = perMppt;
                            }
                            
                            return perMpptFinal !== null ? `${perMpptFinal}A` : 'N/A';
                        })()}</div>
                        <div><i class="fa-solid fa-arrow-up text-red-500 mr-1"></i><span class="font-semibold">最大輸入電壓:</span> ${inv.max_input_voltage_v}V</div>
                    `;
                    App.ui.calcInvTotal();
                    App.calc.runDebounced();
                },
                calcInvTotal: () => {
                    let tot = 0;
                    document.querySelectorAll('#inverterListBody tr').forEach(tr => {
                        const sel = tr.querySelector('select');
                        const qty = tr.querySelectorAll('input')[1]; // 2nd input is quantity
                        if (sel && sel.value && qty) tot += App.cache.inverters[sel.value].rated_output_power_kw * parseFloat(qty.value || 0);
                    });
                    document.getElementById('inverterTotalDisplay').innerText = tot.toFixed(2) + " kW";
                },
                renderTables: () => {
                   // 安培容量表 - 顯示所有欄位
                   // 動態生成表格行，包含所有可能的欄位
                   const rAmp = (r) => {
                       // 獲取所有欄位（排除id、created_at等系統欄位）
                       const excludeFields = ['id', 'created_at', 'updated_at', 'uuid'];
                       const fields = Object.keys(r).filter(k => !excludeFields.includes(k));
                       
                       // 找出線徑欄位（通常是第一個或包含size/area的欄位）
                       const sizeField = fields.find(f => 
                           f.includes('size') || f.includes('area') || f.includes('nominal') || 
                           f.includes('wire_size') || f === 'size'
                       ) || fields[0];
                       
                       // 其他欄位都是安培容量值
                       const ampFields = fields.filter(f => f !== sizeField && !excludeFields.includes(f));
                       
                       // 生成表格行
                       let row = `<tr class="hover:bg-blue-50 transition"><td class="border-r font-bold p-2">${r[sizeField] || 'N/A'}</td>`;
                       ampFields.forEach(field => {
                           const value = r[field];
                           row += `<td class="p-2">${value !== null && value !== undefined && value !== '' ? value : '-'}</td>`;
                       });
                       row += '</tr>';
                       return row;
                   };
                   
                   // 生成表頭（動態）
                   const generateAmpTableHeader = (data) => {
                       if (!data || data.length === 0) return '<tr><th class="p-2 border-r">線徑 (mm²)</th><th class="p-2">3條 (A)</th><th class="p-2">4條 (A)</th></tr>';
                       
                       const excludeFields = ['id', 'created_at', 'updated_at', 'uuid'];
                       const fields = Object.keys(data[0]).filter(k => !excludeFields.includes(k));
                       const sizeField = fields.find(f => 
                           f.includes('size') || f.includes('area') || f.includes('nominal') || 
                           f.includes('wire_size') || f === 'size'
                       ) || fields[0];
                       const ampFields = fields.filter(f => f !== sizeField && !excludeFields.includes(f));
                       
                       let header = `<tr><th class="p-2 border-r">線徑 (mm²)</th>`;
                       ampFields.forEach(field => {
                           // 將欄位名轉換為中文標籤
                           let label = field;
                           if (field.includes('amp_1') || field.includes('1_wire') || field.includes('1_core')) label = '1條 (A)';
                           else if (field.includes('amp_2') || field.includes('2_wire') || field.includes('2_core')) label = '2條 (A)';
                           else if (field.includes('amp_3') || field.includes('3_wire') || field.includes('3_core') || field.includes('3_below')) label = '3條 (A)';
                           else if (field.includes('amp_4') || field.includes('4_wire') || field.includes('4_core')) label = '4條 (A)';
                           else if (field.includes('amp_5') || field.includes('5_wire') || field.includes('5_core')) label = '5條 (A)';
                           else if (field.includes('amp_6') || field.includes('6_wire') || field.includes('6_core')) label = '6條 (A)';
                           else label = field.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                           header += `<th class="p-2">${label}</th>`;
                       });
                       header += '</tr>';
                       return header;
                   };
                   // 渲染安培容量表（動態表頭和所有欄位）
                   const renderAmpTable = (data, tbodyId, headerId, defaultColspan = 3) => {
                       const tbody = document.getElementById(tbodyId);
                       const header = document.getElementById(headerId);
                       if (!tbody) return;
                       
                       if (data && data.length > 0) {
                           // 生成動態表頭
                           if (header) {
                               header.innerHTML = generateAmpTableHeader(data);
                           }
                           // 生成表格內容
                           tbody.innerHTML = data.map(rAmp).join('');
                       } else {
                           if (header) {
                               header.innerHTML = '<tr><th class="p-2 border-r">線徑 (mm²)</th><th class="p-2">3條 (A)</th><th class="p-2">4條 (A)</th></tr>';
                           }
                           tbody.innerHTML = `<tr><td colspan="${defaultColspan}" class="text-center text-gray-400 p-4">資料載入中...</td></tr>`;
                       }
                   };
                   
                   renderAmpTable(App.cache.ampPVC, 'ampTablePVC', 'ampTablePVCHeader');
                   renderAmpTable(App.cache.ampMetal60, 'ampTableMetal60', 'ampTableMetal60Header');
                   renderAmpTable(App.cache.ampMetal75, 'ampTableMetal75', 'ampTableMetal75Header');
                   renderAmpTable(App.cache.ampMetal90, 'ampTableMetal90', 'ampTableMetal90Header');
                   
                   // 管徑表渲染函數（動態生成表頭和內容，支援所有欄位）
                   const renderPipeTable = (data, tbodyId, headerId) => {
                       const tbody = document.getElementById(tbodyId);
                       const header = document.getElementById(headerId);
                       if (!tbody) return;
                       
                       if (data && data.length > 0) {
                           // 獲取所有欄位（排除系統欄位）
                           const excludeFields = ['id', 'created_at', 'updated_at', 'uuid'];
                           const fields = Object.keys(data[0]).filter(k => !excludeFields.includes(k));
                           
                           // 找出線徑欄位
                           const sizeField = fields.find(f => 
                               f.includes('size') || f.includes('wire_size') || f === 'wire_size_mm'
                           ) || fields[0];
                           
                           // 其他欄位都是管徑值（2條、3條、4條、5條等）
                           const pipeFields = fields.filter(f => f !== sizeField && !excludeFields.includes(f));
                           
                           // 按欄位名稱排序（確保順序正確：2條、3條、4條...）
                           pipeFields.sort((a, b) => {
                               const getNum = (str) => {
                                   const match = str.match(/\d+/);
                                   return match ? parseInt(match[0]) : 999;
                               };
                               return getNum(a) - getNum(b);
                           });
                           
                           // 生成表頭
                           if (header) {
                               let headerHtml = `<th class="p-2 border-r">線徑 (mm)</th>`;
                               pipeFields.forEach(field => {
                                   // 將欄位名轉換為中文標籤
                                   let label = field;
                                   const numMatch = field.match(/\d+/);
                                   if (numMatch) {
                                       label = `${numMatch[0]}條`;
                                   } else if (field.includes('2') || field.includes('wires_2') || field.includes('pipe_size_2')) label = '2條';
                                   else if (field.includes('3') || field.includes('wires_3') || field.includes('pipe_size_3')) label = '3條';
                                   else if (field.includes('4') || field.includes('wires_4') || field.includes('pipe_size_4')) label = '4條';
                                   else if (field.includes('5') || field.includes('wires_5') || field.includes('pipe_size_5')) label = '5條';
                                   else if (field.includes('6') || field.includes('wires_6') || field.includes('pipe_size_6')) label = '6條';
                                   else if (field.includes('7') || field.includes('wires_7') || field.includes('pipe_size_7')) label = '7條';
                                   else if (field.includes('8') || field.includes('wires_8') || field.includes('pipe_size_8')) label = '8條';
                                   else label = field.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                                   headerHtml += `<th class="p-2">${label}</th>`;
                               });
                               header.innerHTML = headerHtml;
                           }
                           
                           // 生成表格內容
                           tbody.innerHTML = data.map(r => {
                               let row = `<tr class="hover:bg-blue-50 transition"><td class="border-r font-bold p-2">${r[sizeField] || 'N/A'}</td>`;
                               pipeFields.forEach(field => {
                                   const value = r[field];
                                   row += `<td class="p-2">${value !== null && value !== undefined && value !== '' ? value : '-'}</td>`;
                               });
                               row += '</tr>';
                               return row;
                           }).join('');
                       } else {
                           if (header) {
                               header.innerHTML = '<th class="p-2 border-r">線徑 (mm)</th><th class="p-2">2條</th><th class="p-2">3條</th><th class="p-2">4條</th>';
                           }
                           tbody.innerHTML = '<tr><td colspan="4" class="text-center text-gray-400 p-4">資料載入中或無資料...</td></tr>';
                       }
                   };
                   
                   // 管徑表 - 非金屬管 (PVC)
                   renderPipeTable(App.cache.conduit, 'pipeTableBody', 'pipeTableHeader');
                   
                   // 管徑表 - 非金屬軟管
                   renderPipeTable(App.cache.conduitFlexNonMetal, 'pipeTableFlexNonMetalBody', 'pipeTableFlexNonMetalHeader');
                   
                   // 管徑表 - 金屬薄管
                   renderPipeTable(App.cache.conduitThinMetal, 'pipeTableThinMetalBody', 'pipeTableThinMetalHeader');
                   
                   // 管徑表 - 金屬厚管
                   renderPipeTable(App.cache.conduitThickMetal, 'pipeTableThickMetalBody', 'pipeTableThickMetalHeader');
                   
                   // 阻抗表
                   if(document.getElementById('impedanceTableBody')) {
                       const tbody = document.getElementById('impedanceTableBody');
                       if (App.cache.impedance.length > 0) {
                           tbody.innerHTML = App.cache.impedance.map(r=>`<tr class="hover:bg-blue-50 transition"><td class="font-bold text-blue-600 p-2">${r.insulation_type||'N/A'}</td><td class="p-2">${r.wire_size_label||r.wire_size||'N/A'}</td><td class="p-2 font-mono">${r.r_ohm||r.resistance_ohm_per_km||'N/A'}</td><td class="p-2 font-mono">${r.x_ohm||r.reactance_ohm_per_km||'N/A'}</td></tr>`).join('');
                       } else {
                           tbody.innerHTML = '<tr><td colspan="4" class="text-center text-gray-400 p-4">資料載入中...</td></tr>';
                       }
                   }

                   // 通用表格渲染（用於接地 / breaker standard）
                   const renderGenericTable = (data, headerId, bodyId) => {
                       const thead = document.getElementById(headerId);
                       const tbody = document.getElementById(bodyId);
                       if (!thead || !tbody) return;
                       
                       if (!Array.isArray(data) || data.length === 0) {
                           thead.innerHTML = '<tr><th class="p-2">資料</th></tr>';
                           tbody.innerHTML = '<tr><td class="text-center text-gray-400 p-4">資料載入中或無資料...</td></tr>';
                           return;
                       }
                       
                       const exclude = new Set(['id', 'created_at', 'updated_at', 'uuid']);
                       const cols = Object.keys(data[0] || {}).filter(k => !exclude.has(k));
                       const safeCols = cols.length ? cols : Object.keys(data[0] || {});
                       
                       const label = (k) => String(k).replace(/_/g, ' ');
                       thead.innerHTML = `<tr>${safeCols.map(c => `<th class="p-2 border-b">${label(c)}</th>`).join('')}</tr>`;
                       
                       const esc = (v) => String(v ?? '')
                           .replace(/&/g, '&amp;')
                           .replace(/</g, '&lt;')
                           .replace(/>/g, '&gt;')
                           .replace(/"/g, '&quot;');
                       
                       tbody.innerHTML = data.map(row => {
                           return `<tr class="hover:bg-blue-50 transition">${safeCols.map(c => {
                               const v = row?.[c];
                               return `<td class="p-2 border-b">${v === null || v === undefined || v === '' ? '-' : esc(v)}</td>`;
                           }).join('')}</tr>`;
                       }).join('');
                   };
                   
                   renderGenericTable(App.cache.groundTypes, 'groundTypeTableHeader', 'groundTypeTableBody');
                   renderGenericTable(App.cache.groundingConductorWireSizing, 'groundingConductorWireSizingTableHeader', 'groundingConductorWireSizingTableBody');
                   renderGenericTable(App.cache.breakerStandards, 'breakerStdTableHeader', 'breakerStdTableBody');
                   
                   if(document.getElementById('inverterTableBody')) document.getElementById('inverterTableBody').innerHTML = App.cache.inverters.map((i,x)=>`<tr class="cursor-pointer border-b hover:bg-blue-50 transition" onclick="App.ui.openDetail('inverter',${x})"><td class="p-3 text-blue-600 font-bold">${i.model_name}</td><td class="p-3">${i.rated_output_power_kw}</td><td class="p-3">${i.max_input_voltage_v}</td><td class="p-3">${i.num_mpp_trackers}</td><td class="p-3">${i.max_efficiency_percent}%</td><td class="p-3 text-center"><i class="fa-solid fa-info-circle text-gray-400"></i></td></tr>`).join('');
                   if(document.getElementById('moduleTableBody')) document.getElementById('moduleTableBody').innerHTML = App.cache.modules.map((m,x)=>`<tr class="cursor-pointer border-b hover:bg-blue-50 transition" onclick="App.ui.openDetail('module',${x})"><td class="p-3">${m.manufacturer}</td><td class="p-3 font-bold text-blue-600">${m.model_number}</td><td class="p-3">${m.p_max}</td><td class="p-3">${m.v_oc}</td><td class="p-3">${m.i_sc}</td><td class="p-3 text-center"><i class="fa-solid fa-info-circle text-gray-400"></i></td></tr>`).join('');
                },
                filterTable: (id, q) => document.querySelectorAll(`#${id} tbody tr`).forEach(r => r.style.display = r.textContent.toUpperCase().includes(q.toUpperCase()) ? '' : 'none'),
                openDetail: (type, idx) => {
                    const data = type === 'inverter' ? App.cache.inverters[idx] : App.cache.modules[idx];
                    if(!data) return;
                    
                    const title = type === 'inverter' ? data.model_name : `${data.manufacturer || ''} ${data.model_number || ''}`.trim();
                    document.getElementById('modalTitle').innerText = title;
                    
                    // 分類顯示欄位
                    const categories = {
                        basic: { title: '基本規格', en: 'Basic Specifications', fields: [] },
                        electrical: { title: '電氣規格', en: 'Electrical Specifications', fields: [] },
                        mppt: { title: 'MPPT 規格', en: 'MPPT Specifications', fields: [] },
                        physical: { title: '物理規格', en: 'Physical Specifications', fields: [] },
                        other: { title: '其他資訊', en: 'Other Information', fields: [] }
                    };
                    
                    // 逆變器分類
                    if (type === 'inverter') {
                        const mpptFields = ['num_mpp_trackers', 'mppt_voltage_range_v', 'max_input_current_per_mppt_a'];
                        const elecFields = ['rated_output_power_kw', 'max_input_voltage_v', 'rated_input_voltage_v', 'max_efficiency_percent'];
                        const basicFields = ['model_name', 'manufacturer', 'series'];
                        
                        for(const [k, v] of Object.entries(data)) {
                            // 跳過系統欄位和空值
                            if(['id','created_at','updated_at','uuid','image_url','datasheet_url'].includes(k)) continue;
                            if(v === null || v === undefined || v === '') continue;
                            
                            const field = FieldMap[k];
                            // 如果欄位不在對照表中，使用預設格式
                            let label = field ? field.zh : k.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            let labelEn = field ? field.en : k.replace(/_/g, ' ');
                            let icon = field ? field.icon : 'fa-info-circle';
                            let value = v;
                            if (field && field.unit) value = v + ` ${field.unit}`;
                            
                            const item = { key: k, label, labelEn, value, icon };
                            
                            if (mpptFields.includes(k)) categories.mppt.fields.push(item);
                            else if (elecFields.includes(k)) categories.electrical.fields.push(item);
                            else if (basicFields.includes(k)) categories.basic.fields.push(item);
                            else categories.other.fields.push(item);
                        }
                    } else {
                        // 模組分類
                        const elecFields = ['p_max', 'v_oc', 'i_sc', 'v_mp', 'i_mp'];
                        const basicFields = ['model_number', 'manufacturer', 'series', 'cell_type'];
                        const physFields = ['dimensions_mm', 'weight_kg'];
                        
                        for(const [k, v] of Object.entries(data)) {
                            // 跳過系統欄位和空值
                            if(['id','created_at','updated_at','uuid','image_url','datasheet_url'].includes(k)) continue;
                            if(v === null || v === undefined || v === '') continue;
                            
                            const field = FieldMap[k];
                            // 如果欄位不在對照表中，使用預設格式
                            let label = field ? field.zh : k.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            let labelEn = field ? field.en : k.replace(/_/g, ' ');
                            let icon = field ? field.icon : 'fa-info-circle';
                            let value = v;
                            if (field && field.unit) value = v + ` ${field.unit}`;
                            
                            const item = { key: k, label, labelEn, value, icon };
                            
                            if (elecFields.includes(k)) categories.electrical.fields.push(item);
                            else if (basicFields.includes(k)) categories.basic.fields.push(item);
                            else if (physFields.includes(k)) categories.physical.fields.push(item);
                            else categories.other.fields.push(item);
                        }
                    }
                    
                    // 生成 HTML
                    let html = '';
                    Object.values(categories).forEach(cat => {
                        if (cat.fields.length === 0) return;
                        html += `
                            <div class="mb-6">
                                <h3 class="text-lg font-bold text-slate-800 mb-3 pb-2 border-b-2 border-blue-500">
                                    <i class="fa-solid fa-folder-open text-blue-600 mr-2"></i>
                                    ${cat.title} <span class="text-sm font-normal text-gray-500">(${cat.en})</span>
                                </h3>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                                    ${cat.fields.map(f => `
                                        <div class="bg-gradient-to-br from-slate-50 to-white p-4 rounded-lg border border-slate-200 shadow-sm hover:shadow-md transition">
                                            <div class="flex items-start gap-3">
                                                <div class="bg-blue-100 text-blue-600 p-2 rounded-lg">
                                                    <i class="fa-solid ${f.icon}"></i>
                                                </div>
                                                <div class="flex-1">
                                                    <div class="text-xs text-gray-500 uppercase font-bold mb-1">${f.label}</div>
                                                    <div class="text-xs text-gray-400 italic mb-2">${f.labelEn}</div>
                                                    <div class="text-base font-bold text-slate-800">${f.value}</div>
                                                </div>
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    });
                    
                    document.getElementById('modalBody').innerHTML = html || '<div class="text-gray-400 text-center p-8">無詳細資料</div>';
                    document.getElementById('detailModal').classList.remove('hidden'); 
                    document.getElementById('detailModal').classList.add('flex');
                },
                closeModal: () => { document.getElementById('detailModal').classList.add('hidden'); document.getElementById('detailModal').classList.remove('flex'); }
            },

            calc: {
                timer: null,
                runDebounced: () => { 
                    clearTimeout(App.calc.timer); 
                    App.calc.timer = setTimeout(() => {
                        App.calc.execute();
                    }, 300); 
                },
                
                execute: () => {
                    console.log('開始執行計算...');
                    // 1. Basic Params & Electrical Calculation
                    const dropLog = document.getElementById('dropLog');
                    const scLog = document.getElementById('scLog');
                    // 計算規劃容量：片數 × 模組功率
                    const modIdx = document.getElementById('activeModuleSelect').value;
                    const plannedPanels = parseFloat(document.getElementById('plannedPanels').value || 0);
                    let P_kW = 0;
                    if (modIdx !== "" && plannedPanels > 0) {
                        const mod = App.cache.modules[modIdx];
                        if (mod) {
                            P_kW = (plannedPanels * mod.p_max) / 1000; // 轉換為 kW
                            // 更新顯示的容量
                            const capEl = document.getElementById('capacityValue');
                            if (capEl) capEl.textContent = P_kW.toFixed(2) + ' kW';
                        }
                    } else {
                        const capEl = document.getElementById('capacityValue');
                        if (capEl) capEl.textContent = '0.00 kW';
                    }
                    const gridVoltageValue = document.getElementById('gridVoltage').value;
                    const is3Ph = !gridVoltageValue.includes('_1ph'); // 判斷是否為三相
                    const V_line = parseFloat(gridVoltageValue.replace('_1ph', ''));
                    const sourceMVA = parseFloat(document.getElementById('sourceMVA').value) || 250;
                    
                    dropLog.innerHTML = ''; 
                    scLog.innerHTML = '';
                    App.reportData.vd = []; 
                    App.reportData.sc = [];
                    
                    // 電壓降計算（專業版 - 含完整公式）
                    if (P_kW > 0 && V_line > 0) {
                        const PF = 0.9; // 功率因數
                        const sinPhi = Math.sqrt(1 - PF * PF);
                        // 電流計算係數：三相 √3；單相 1
                        const K_current = is3Ph ? 1.732 : 1.0;
                        // 電壓降係數：三相 √3；單相 2（往返導線）
                        const K_vd = is3Ph ? 1.732 : 2.0;
                        const I_b = (P_kW * 1000) / (K_current * V_line);
                        
                        // 儲存到 reportData
                        const phaseType = is3Ph ? '三相系統' : '單相系統';
                        const phaseFormula = is3Ph ? 'I<sub>b</sub> = P / (√3 × V)' : 'I<sub>b</sub> = P / V';
                        const phaseCalc = is3Ph ? `1.732 × ${V_line}` : `${V_line}`;
                        
                        App.reportData.vd.push({
                            title: '1. 設計電流 (Design Current) I<sub>b</sub>',
                            params: `系統參數: P = ${P_kW} kW, V = ${V_line} V, PF = ${PF}, ${phaseType}`,
                            formula: `公式: ${phaseFormula}`,
                            process: `計算過程: I<sub>b</sub> = ${(P_kW*1000).toFixed(0)} / (${phaseCalc})`,
                            result: `結果: I<sub>b</sub> = ${I_b.toFixed(2)} A`
                        });
                        
                        dropLog.innerHTML += `
                            <div class="calc-block">
                                <span class="calc-title">1. 設計電流 (Design Current) Ib</span>
                                <span class="calc-param">系統參數: P = ${P_kW} kW, V = ${V_line} V, PF = ${PF}, ${phaseType}</span>
                                <span class="calc-formula">公式: ${phaseFormula}</span>
                                <span class="calc-process">計算過程: I_b = ${(P_kW*1000).toFixed(0)} / (${phaseCalc})</span>
                                <span class="calc-result">結果: I_b = ${I_b.toFixed(2)} A</span>
                            </div>`;
                        
                        const cable1Idx = document.getElementById('cableSelect1').value;
                        const len1 = parseFloat(document.getElementById('len1').value) || 0;
                        const cable2Idx = document.getElementById('cableSelect2').value;
                        const len2 = parseFloat(document.getElementById('len2').value) || 0;
                        const cable3Idx = document.getElementById('cableSelect3')?.value || '';
                        const len3 = parseFloat(document.getElementById('len3')?.value || 0);
                        const hasTr = document.getElementById('hasTransformer')?.checked || false;
                        
                        // 計算最大功率的單台逆變器（用於二次側線路計算）
                        let maxSingleInverterPower = 0;
                        const inverterRows = document.querySelectorAll('#inverterListBody tr');
                        inverterRows.forEach(tr => {
                            const sel = tr.querySelector('select');
                            if (sel && sel.value) {
                                const inv = App.cache.inverters[sel.value];
                                if (inv && inv.rated_output_power_kw > maxSingleInverterPower) {
                                    maxSingleInverterPower = inv.rated_output_power_kw;
                                }
                            }
                        });
                        
                        // 如果沒有逆變器配置，使用總功率
                        if (maxSingleInverterPower === 0) {
                            maxSingleInverterPower = P_kW;
                        }
                        
                        let totalDrop = 0;
                        let segmentNum = 2;
                        
                        if (cable1Idx && len1 > 0) {
                            const cable1 = App.cache.impedance[cable1Idx];
                            if (cable1) {
                                const R = cable1.r_ohm || cable1.resistance_ohm_per_km || 0;
                                const X = cable1.x_ohm || cable1.reactance_ohm_per_km || 0;
                                const L_km = len1 / 1000;
                                const Vd1 = K_vd * I_b * (R * PF + X * sinPhi) * L_km;
                                const Vd1_pct = (Vd1 / V_line) * 100;
                                totalDrop += Vd1;
                                
                                const vdFormula = is3Ph
                                    ? 'ΔV = √3 × I<sub>b</sub> × (R·cosθ + X·sinθ) × L'
                                    : 'ΔV = 2 × I<sub>b</sub> × (R·cosθ + X·sinθ) × L';
                                const vdCalc = is3Ph ? `1.732 × ${I_b.toFixed(2)}` : `2 × ${I_b.toFixed(2)}`;
                                
                                App.reportData.vd.push({
                                    title: `${segmentNum}. 責任分界點線路 (Service Point Cable)`,
                                    params: `線徑: ${cable1.wire_size_label || 'N/A'} (${cable1.total_area_mm2 || 'N/A'}mm²), R = ${R} Ω/km, X = ${X} Ω/km, L = ${len1}m (${L_km}km)`,
                                    formula: `公式: ${vdFormula}`,
                                    process: `計算過程: ΔV = ${vdCalc} × (${R}×${PF} + ${X}×${sinPhi.toFixed(3)}) × ${L_km}`,
                                    result: `結果: ΔV₁ = ${Vd1.toFixed(2)} V (${Vd1_pct.toFixed(2)}%)`
                                });
                                
                                dropLog.innerHTML += `
                                    <div class="calc-block">
                                        <span class="calc-title">${segmentNum}. 責任分界點線路 (Service Point Cable)</span>
                                        <span class="calc-param">線徑: ${cable1.wire_size_label || 'N/A'} (${cable1.total_area_mm2 || 'N/A'}mm²), R = ${R} Ω/km, X = ${X} Ω/km, L = ${len1}m (${L_km}km)</span>
                                        <span class="calc-formula">公式: ${vdFormula}</span>
                                        <span class="calc-process">計算過程: ΔV = ${vdCalc} × (${R}×${PF} + ${X}×${sinPhi.toFixed(3)}) × ${L_km}</span>
                                        <span class="calc-result">結果: ΔV₁ = ${Vd1.toFixed(2)} V (${Vd1_pct.toFixed(2)}%)</span>
                                </div>`;
                                segmentNum++;
                            }
                        }
                        
                        if (cable2Idx && len2 > 0) {
                            const cable2 = App.cache.impedance[cable2Idx];
                            if (cable2) {
                                const R = cable2.r_ohm || cable2.resistance_ohm_per_km || 0;
                                const X = cable2.x_ohm || cable2.reactance_ohm_per_km || 0;
                                const L_km = len2 / 1000;
                                const Vd2 = K_vd * I_b * (R * PF + X * sinPhi) * L_km;
                                const Vd2_pct = (Vd2 / V_line) * 100;
                                totalDrop += Vd2;
                                
                                const vd2Formula = is3Ph
                                    ? 'ΔV = √3 × I<sub>b</sub> × (R·cosθ + X·sinθ) × L'
                                    : 'ΔV = 2 × I<sub>b</sub> × (R·cosθ + X·sinθ) × L';
                                const vd2Calc = is3Ph ? `1.732 × ${I_b.toFixed(2)}` : `2 × ${I_b.toFixed(2)}`;
                                
                                App.reportData.vd.push({
                                    title: `${segmentNum}. 幹線迴路 (Main Feeder)`,
                                    params: `線徑: ${cable2.wire_size_label || 'N/A'} (${cable2.total_area_mm2 || 'N/A'}mm²), R = ${R} Ω/km, X = ${X} Ω/km, L = ${len2}m (${L_km}km)`,
                                    formula: `公式: ${vd2Formula}`,
                                    process: `計算過程: ΔV = ${vd2Calc} × (${R}×${PF} + ${X}×${sinPhi.toFixed(3)}) × ${L_km}`,
                                    result: `結果: ΔV₂ = ${Vd2.toFixed(2)} V (${Vd2_pct.toFixed(2)}%)`
                                });
                                
                                dropLog.innerHTML += `
                                    <div class="calc-block">
                                        <span class="calc-title">${segmentNum}. 幹線迴路 (Main Feeder)</span>
                                        <span class="calc-param">線徑: ${cable2.wire_size_label || 'N/A'} (${cable2.total_area_mm2 || 'N/A'}mm²), R = ${R} Ω/km, X = ${X} Ω/km, L = ${len2}m (${L_km}km)</span>
                                        <span class="calc-formula">公式: ${vd2Formula}</span>
                                        <span class="calc-process">計算過程: ΔV = ${vd2Calc} × (${R}×${PF} + ${X}×${sinPhi.toFixed(3)}) × ${L_km}</span>
                                        <span class="calc-result">結果: ΔV₂ = ${Vd2.toFixed(2)} V (${Vd2_pct.toFixed(2)}%)</span>
                                </div>`;
                                segmentNum++;
                            }
                        }
                        
                        if (hasTr) {
                            const Z_pct = P_kW >= 1000 ? 6 : 4;
                            const Z_base = (V_line * V_line) / (P_kW * 1000);
                            const Z_tr_ohm = (Z_pct / 100) * Z_base;
                            const X_tr = Z_tr_ohm * 0.98;
                            const R_tr = Z_tr_ohm * 0.2;
                            const Vd_tr = K_current * I_b * (R_tr * PF + X_tr * sinPhi);
                            const Vd_tr_pct = (Vd_tr / V_line) * 100;
                            totalDrop += Vd_tr;
                            
                            const vdTrFormula = is3Ph ? 'ΔV<sub>tr</sub> ≈ √3 × I<sub>b</sub> × (R<sub>tr</sub>·cosθ + X<sub>tr</sub>·sinθ)' : 'ΔV<sub>tr</sub> ≈ I<sub>b</sub> × (R<sub>tr</sub>·cosθ + X<sub>tr</sub>·sinθ)';
                            const vdTrCalc = is3Ph ? `1.732 × ${I_b.toFixed(2)}` : `${I_b.toFixed(2)}`;
                            
                            App.reportData.vd.push({
                                title: `${segmentNum}. 變壓器壓降 (Transformer Voltage Drop)`,
                                params: `變壓器容量: ${P_kW} kVA, 阻抗百分比: Z% = ${Z_pct}%, Z_base = ${Z_base.toFixed(4)}Ω`,
                                formula: `公式: ${vdTrFormula}`,
                                process: `計算過程: ΔV<sub>tr</sub> = ${vdTrCalc} × (${R_tr.toFixed(4)}×${PF} + ${X_tr.toFixed(4)}×${sinPhi.toFixed(3)})`,
                                result: `結果: ΔV<sub>tr</sub> = ${Vd_tr.toFixed(2)} V (${Vd_tr_pct.toFixed(2)}%)`
                            });
                            
                            dropLog.innerHTML += `
                                <div class="calc-block">
                                    <span class="calc-title">${segmentNum}. 變壓器壓降 (Transformer Voltage Drop)</span>
                                    <span class="calc-param">變壓器容量: ${P_kW} kVA, 阻抗百分比: Z% = ${Z_pct}%, Z_base = ${Z_base.toFixed(4)}Ω</span>
                                    <span class="calc-formula">公式: ${vdTrFormula}</span>
                                    <span class="calc-process">計算過程: ΔV_tr = ${vdTrCalc} × (${R_tr.toFixed(4)}×${PF} + ${X_tr.toFixed(4)}×${sinPhi.toFixed(3)})</span>
                                    <span class="calc-result">結果: ΔV_tr = ${Vd_tr.toFixed(2)} V (${Vd_tr_pct.toFixed(2)}%)</span>
                                </div>`;
                            segmentNum++;
                            
                            // 二次側線路（逆變器到變壓器）- 使用最大功率的單台逆變器
                            if (cable3Idx && len3 > 0 && maxSingleInverterPower > 0) {
                                const cable3 = App.cache.impedance[cable3Idx];
                                if (cable3) {
                                    const I_b_secondary = (maxSingleInverterPower * 1000) / (K_current * V_line);
                                    const R = cable3.r_ohm || cable3.resistance_ohm_per_km || 0;
                                    const X = cable3.x_ohm || cable3.reactance_ohm_per_km || 0;
                                    const L_km = len3 / 1000;
                                    const Vd3 = K_vd * I_b_secondary * (R * PF + X * sinPhi) * L_km;
                                    const Vd3_pct = (Vd3 / V_line) * 100;
                                    totalDrop += Vd3;
                                    
                                    const vd3Formula = is3Ph
                                        ? 'ΔV = √3 × I_b × (R·cosθ + X·sinθ) × L'
                                        : 'ΔV = 2 × I_b × (R·cosθ + X·sinθ) × L';
                                    const vd3Calc = is3Ph ? `1.732 × ${I_b_secondary.toFixed(2)}` : `2 × ${I_b_secondary.toFixed(2)}`;
                                    
                                    App.reportData.vd.push({
                                        title: `${segmentNum}. 二次側線路 (Secondary Circuit) - 單台最大功率`,
                                        params: `線徑: ${cable3.wire_size_label || 'N/A'} (${cable3.total_area_mm2 || 'N/A'}mm²), R = ${R} Ω/km, X = ${X} Ω/km, L = ${len3}m (${L_km}km), 使用功率: ${maxSingleInverterPower} kW (最大單台)`,
                                        formula: `公式: ${vd3Formula}`,
                                        process: `計算過程: ΔV = ${vd3Calc} × (${R}×${PF} + ${X}×${sinPhi.toFixed(3)}) × ${L_km}`,
                                        result: `結果: ΔV₃ = ${Vd3.toFixed(2)} V (${Vd3_pct.toFixed(2)}%)`
                                    });
                                    
                                    dropLog.innerHTML += `
                                        <div class="calc-block">
                                            <span class="calc-title">${segmentNum}. 二次側線路 (Secondary Circuit) - 單台最大功率</span>
                                            <span class="calc-param">線徑: ${cable3.wire_size_label || 'N/A'} (${cable3.total_area_mm2 || 'N/A'}mm²), R = ${R} Ω/km, X = ${X} Ω/km, L = ${len3}m (${L_km}km)</span>
                                            <span class="calc-param" style="color:#f59e0b;">使用功率: ${maxSingleInverterPower} kW (最大單台逆變器功率，用於二次迴路計算)</span>
                                            <span class="calc-formula">公式: ${vd3Formula}</span>
                                            <span class="calc-process">計算過程: ΔV = ${vd3Calc} × (${R}×${PF} + ${X}×${sinPhi.toFixed(3)}) × ${L_km}</span>
                                            <span class="calc-result">結果: ΔV₃ = ${Vd3.toFixed(2)} V (${Vd3_pct.toFixed(2)}%)</span>
                                        </div>`;
                                }
                            }
                        }
                        
                        if (totalDrop > 0) {
                            const totalPct = (totalDrop / V_line) * 100;
                            App.reportData.totalVd = `${totalPct.toFixed(2)}%`;
                            dropLog.innerHTML += `
                                <div class="mt-4 p-3 bg-slate-800 border border-slate-600 rounded text-center">
                                    <span class="text-gray-400 text-sm block mb-1">系統總電壓降 (Total Voltage Drop)</span>
                                    <span class="text-2xl font-bold ${totalPct>3?'text-red-500':'text-green-500'}">${totalPct.toFixed(2)}%</span>
                                    <span class="text-gray-300 text-xs block mt-1">(${totalDrop.toFixed(2)} V / ${V_line} V × 100%)</span>
                            </div>`;
                        }
                        
                        // 短路電流計算（僅三相系統需要計算）
                        if (!is3Ph) {
                            scLog.innerHTML = '<div class="text-gray-400 text-center p-4"><i class="fa-solid fa-info-circle text-2xl mb-2 block"></i>依低壓用戶斷路器之額定極限短路啟斷容量選用</div>';
                            App.reportData.scFinal = 'N/A (單相系統)';
                        } else {
                        // 短路電流計算（標么值法 - Per Unit Method）
                        // 基準值設定
                        const S_base = 1000; // 基準容量 = 1000 kVA
                        const V_base = V_line; // 基準電壓 = 所選電壓等級
                        const K_phase_sc = Math.sqrt(3); // √3（用於短路電流計算）
                        
                        // 計算基準電流和基準阻抗
                        const I_base = (S_base * 1000) / (K_phase_sc * V_base); // 基準電流 (A)
                        const Z_base = (V_base * V_base) / (S_base * 1000); // 基準阻抗 (Ω)
                        
                        // 計算電源側阻抗（標么值）
                        const S_sc = sourceMVA * 1000; // 短路容量 (kVA)
                        const Z_grid_actual = (V_line * V_line) / (S_sc * 1000); // 實際阻抗 (Ω)
                        const Z_grid_pu = Z_grid_actual / Z_base; // 標么阻抗
                        const X_grid_pu = Z_grid_pu; // 假設電源側主要為電抗
                        
                        App.reportData.sc.push({
                            title: '1. 基準值設定 (Base Values)',
                            params: `基準容量: S<sub>base</sub> = ${S_base} kVA, 基準電壓: V<sub>base</sub> = ${V_base} V`,
                            formula: '公式: I<sub>base</sub> = S<sub>base</sub> / (√3 × V<sub>base</sub>), Z<sub>base</sub> = V<sub>base</sub>² / S<sub>base</sub>',
                            process: `計算過程: I<sub>base</sub> = ${S_base} / (1.732 × ${V_base}) = ${I_base.toFixed(2)} A, Z_base = ${V_base}² / ${S_base} = ${Z_base.toFixed(6)} Ω`,
                            result: `結果: I<sub>base</sub> = ${I_base.toFixed(2)} A, Z_base = ${Z_base.toFixed(6)} Ω`
                        });
                        
                        App.reportData.sc.push({
                            title: '2. 電源側阻抗（標么值）(Source Impedance in Per Unit)',
                            params: `短路容量: S<sub>sc</sub> = ${sourceMVA} MVA, 系統電壓: V = ${V_line} V`,
                            formula: '公式: Z<sub>grid_pu</sub> = (V² / S<sub>sc</sub>) / Z<sub>base</sub>',
                            process: `計算過程: Z<sub>grid_actual</sub> = ${V_line}² / ${S_sc} = ${Z_grid_actual.toFixed(6)} Ω, Z<sub>grid_pu</sub> = ${Z_grid_actual.toFixed(6)} / ${Z_base.toFixed(6)} = ${Z_grid_pu.toFixed(6)}`,
                            result: `結果: Z<sub>grid_pu</sub> = ${Z_grid_pu.toFixed(6)} p.u. (X<sub>grid_pu</sub> ≈ ${X_grid_pu.toFixed(6)} p.u.)`
                        });
                        
                        scLog.innerHTML += `
                            <div class="calc-block">
                                <span class="calc-title">1. 基準值設定 (Base Values)</span>
                                <span class="calc-param">基準容量: S_base = ${S_base} kVA, 基準電壓: V_base = ${V_base} V</span>
                                <span class="calc-formula">公式: I_base = S_base / (√3 × V_base), Z_base = V_base² / S_base</span>
                                <span class="calc-process">計算過程: I_base = ${S_base} / (1.732 × ${V_base}) = ${I_base.toFixed(2)} A</span>
                                <span class="calc-process">Z_base = ${V_base}² / ${S_base} = ${Z_base.toFixed(6)} Ω</span>
                                <span class="calc-result">結果: I_base = ${I_base.toFixed(2)} A, Z_base = ${Z_base.toFixed(6)} Ω</span>
                        </div>`;
                        
                        scLog.innerHTML += `
                            <div class="calc-block">
                                <span class="calc-title">2. 電源側阻抗（標么值）(Source Impedance in Per Unit)</span>
                                <span class="calc-param">短路容量: S_sc = ${sourceMVA} MVA, 系統電壓: V = ${V_line} V</span>
                                <span class="calc-formula">公式: Z_grid_pu = (V² / S_sc) / Z_base</span>
                                <span class="calc-process">計算過程: Z_grid_actual = ${V_line}² / ${S_sc} = ${Z_grid_actual.toFixed(6)} Ω</span>
                                <span class="calc-process">Z_grid_pu = ${Z_grid_actual.toFixed(6)} / ${Z_base.toFixed(6)} = ${Z_grid_pu.toFixed(6)}</span>
                                <span class="calc-result">結果: Z_grid_pu = ${Z_grid_pu.toFixed(6)} p.u. (X_grid_pu ≈ ${X_grid_pu.toFixed(6)} p.u.)</span>
                        </div>`;
                        
                        if (hasTr) {
                            // 變壓器阻抗（標么值）
                            const Z_pct = P_kW >= 1000 ? 6 : 4;
                            const Z_tr_pu = Z_pct / 100; // 變壓器阻抗標么值
                            
                            // 短路電流計算：I_sc = V / Z（使用變壓器標么值）
                            // 實際短路電流 = V_base / (Z_tr_pu × Z_base × √3)
                            const I_sc_tr = V_base / (Z_tr_pu * Z_base * K_phase_sc);
                            
                            App.reportData.sc.push({
                                title: '3. 變壓器阻抗（標么值）(Transformer Impedance in Per Unit)',
                                params: `變壓器容量: S_tr = ${P_kW} kVA, 阻抗百分比: Z% = ${Z_pct}%`,
                                formula: '公式: Z<sub>tr_pu</sub> = Z% / 100',
                                process: `計算過程: Z_tr_pu = ${Z_pct}% / 100 = ${Z_tr_pu.toFixed(4)} p.u.`,
                                result: `結果: Z_tr_pu = ${Z_tr_pu.toFixed(4)} p.u.`
                            });
                            
                            App.reportData.sc.push({
                                title: '4. 短路電流計算（變壓器）(Short Circuit Current with Transformer)',
                                params: `系統電壓: V = ${V_base} V, 變壓器阻抗標么值: Z_tr_pu = ${Z_tr_pu.toFixed(4)} p.u., 基準阻抗: Z_base = ${Z_base.toFixed(6)} Ω`,
                                formula: '公式: I_sc = V / (Z_tr_pu × Z_base × √3)',
                                process: `計算過程: I_sc = ${V_base} / (${Z_tr_pu.toFixed(4)} × ${Z_base.toFixed(6)} × 1.732)`,
                                process2: `I_sc = ${V_base} / ${(Z_tr_pu * Z_base * K_phase_sc).toFixed(6)} = ${I_sc_tr.toFixed(2)} A`,
                                result: `結果: I_sc = ${(I_sc_tr/1000).toFixed(2)} kA`
                            });
                            
                            scLog.innerHTML += `
                                <div class="calc-block">
                                    <span class="calc-title">3. 變壓器阻抗（標么值）(Transformer Impedance in Per Unit)</span>
                                    <span class="calc-param">變壓器容量: S_tr = ${P_kW} kVA, 阻抗百分比: Z% = ${Z_pct}%</span>
                                    <span class="calc-formula">公式: Z_tr_pu = Z% / 100</span>
                                    <span class="calc-process">計算過程: Z_tr_pu = ${Z_pct}% / 100 = ${Z_tr_pu.toFixed(4)} p.u.</span>
                                    <span class="calc-result">結果: Z_tr_pu = ${Z_tr_pu.toFixed(4)} p.u.</span>
                                </div>`;
                            
                            scLog.innerHTML += `
                                <div class="calc-block">
                                    <span class="calc-title">4. 短路電流計算（變壓器）(Short Circuit Current with Transformer)</span>
                                    <span class="calc-param">系統電壓: V = ${V_base} V, 變壓器阻抗標么值: Z_tr_pu = ${Z_tr_pu.toFixed(4)} p.u., 基準阻抗: Z_base = ${Z_base.toFixed(6)} Ω</span>
                                    <span class="calc-formula">公式: I_sc = V / (Z_tr_pu × Z_base × √3)</span>
                                    <span class="calc-process">計算過程: I_sc = ${V_base} / (${Z_tr_pu.toFixed(4)} × ${Z_base.toFixed(6)} × 1.732)</span>
                                    <span class="calc-process">I_sc = ${V_base} / ${(Z_tr_pu * Z_base * K_phase_sc).toFixed(6)} = ${I_sc_tr.toFixed(2)} A</span>
                                    <span class="calc-result">結果: I_sc = ${(I_sc_tr/1000).toFixed(2)} kA</span>
                                </div>`;
                            
                            // 儲存最終結果
                            App.reportData.scFinal = `${(I_sc_tr/1000).toFixed(2)} kA`;
                            
                            // 凸顯顯示總結果
                            scLog.innerHTML += `
                                <div class="mt-4 p-3 bg-slate-800 border border-slate-600 rounded text-center">
                                    <span class="text-gray-400 text-sm block mb-1">系統短路電流 (Short Circuit Current)</span>
                                    <span class="text-2xl font-bold text-red-400">${(I_sc_tr/1000).toFixed(2)} kA</span>
                                    <span class="text-gray-300 text-xs block mt-1">標么值計算 (Per Unit Method)</span>
                        </div>`;
                    } else {
                            // 計算線路阻抗（標么值）
                            let R_total = 0, X_total_actual = Z_grid_actual; // 實際阻抗
                            if (cable1Idx && len1 > 0) {
                                const c1 = App.cache.impedance[cable1Idx];
                                if (c1) {
                                    R_total += (c1.r_ohm || 0) * (len1 / 1000);
                                    X_total_actual += (c1.x_ohm || 0) * (len1 / 1000);
                                }
                            }
                            if (cable2Idx && len2 > 0) {
                                const c2 = App.cache.impedance[cable2Idx];
                                if (c2) {
                                    R_total += (c2.r_ohm || 0) * (len2 / 1000);
                                    X_total_actual += (c2.x_ohm || 0) * (len2 / 1000);
                                }
                            }
                            
                            // 轉換為標么值
                            const R_pu = R_total / Z_base;
                            const X_pu = X_total_actual / Z_base;
                            const Z_fault_pu = Math.sqrt(R_pu * R_pu + X_pu * X_pu);
                            
                            // 短路電流標么值
                            const I_sc_pu = 1 / Z_fault_pu;
                            
                            // 實際短路電流
                            const I_sc = I_sc_pu * I_base;
                            
                            App.reportData.sc.push({
                                title: '3. 線路阻抗（標么值）(Line Impedance in Per Unit)',
                                params: `ΣR = ${R_total.toFixed(4)} Ω, ΣX = ${X_total_actual.toFixed(4)} Ω`,
                                formula: '公式: R_pu = R / Z_base, X_pu = X / Z_base, |Z_fault_pu| = √(R_pu² + X_pu²)',
                                process: `計算過程: R_pu = ${R_total.toFixed(4)} / ${Z_base.toFixed(6)} = ${R_pu.toFixed(6)} p.u.`,
                                process2: `X_pu = ${X_total_actual.toFixed(4)} / ${Z_base.toFixed(6)} = ${X_pu.toFixed(6)} p.u.`,
                                process3: `|Z_fault_pu| = √(${R_pu.toFixed(6)}² + ${X_pu.toFixed(6)}²) = ${Z_fault_pu.toFixed(6)} p.u.`,
                                result: `結果: |Z_fault_pu| = ${Z_fault_pu.toFixed(6)} p.u.`
                            });
                            
                            App.reportData.sc.push({
                                title: '4. 短路電流（標么值）(Short Circuit Current in Per Unit)',
                                params: `故障阻抗標么值: |Z_fault_pu| = ${Z_fault_pu.toFixed(6)} p.u., 基準電流: I_base = ${I_base.toFixed(2)} A`,
                                formula: '公式: I_sc_pu = 1 / |Z_fault_pu|, I_sc = I_sc_pu × I_base',
                                process: `計算過程: I_sc_pu = 1 / ${Z_fault_pu.toFixed(6)} = ${I_sc_pu.toFixed(6)} p.u.`,
                                process2: `I_sc = ${I_sc_pu.toFixed(6)} × ${I_base.toFixed(2)} = ${I_sc.toFixed(2)} A`,
                                result: `結果: I_sc = ${(I_sc/1000).toFixed(2)} kA`
                            });
                            
                            scLog.innerHTML += `
                                <div class="calc-block">
                                    <span class="calc-title">3. 線路阻抗（標么值）(Line Impedance in Per Unit)</span>
                                    <span class="calc-param">ΣR = ${R_total.toFixed(4)} Ω, ΣX = ${X_total_actual.toFixed(4)} Ω</span>
                                    <span class="calc-formula">公式: R_pu = R / Z_base, X_pu = X / Z_base, |Z_fault_pu| = √(R_pu² + X_pu²)</span>
                                    <span class="calc-process">計算過程: R_pu = ${R_total.toFixed(4)} / ${Z_base.toFixed(6)} = ${R_pu.toFixed(6)} p.u.</span>
                                    <span class="calc-process">X_pu = ${X_total_actual.toFixed(4)} / ${Z_base.toFixed(6)} = ${X_pu.toFixed(6)} p.u.</span>
                                    <span class="calc-process">|Z_fault_pu| = √(${R_pu.toFixed(6)}² + ${X_pu.toFixed(6)}²) = ${Z_fault_pu.toFixed(6)} p.u.</span>
                                    <span class="calc-result">結果: |Z_fault_pu| = ${Z_fault_pu.toFixed(6)} p.u.</span>
                                </div>`;
                            
                            scLog.innerHTML += `
                                <div class="calc-block">
                                    <span class="calc-title">4. 短路電流（標么值）(Short Circuit Current in Per Unit)</span>
                                    <span class="calc-param">故障阻抗標么值: |Z_fault_pu| = ${Z_fault_pu.toFixed(6)} p.u., 基準電流: I_base = ${I_base.toFixed(2)} A</span>
                                    <span class="calc-formula">公式: I_sc_pu = 1 / |Z_fault_pu|, I_sc = I_sc_pu × I_base</span>
                                    <span class="calc-process">計算過程: I_sc_pu = 1 / ${Z_fault_pu.toFixed(6)} = ${I_sc_pu.toFixed(6)} p.u.</span>
                                    <span class="calc-process">I_sc = ${I_sc_pu.toFixed(6)} × ${I_base.toFixed(2)} = ${I_sc.toFixed(2)} A</span>
                                    <span class="calc-result">結果: I_sc = ${(I_sc/1000).toFixed(2)} kA</span>
                                </div>`;
                            
                            // 儲存最終結果
                            App.reportData.scFinal = `${(I_sc/1000).toFixed(2)} kA`;
                            
                            // 凸顯顯示總結果
                            scLog.innerHTML += `
                                <div class="mt-4 p-3 bg-slate-800 border border-slate-600 rounded text-center">
                                    <span class="text-gray-400 text-sm block mb-1">系統短路電流 (Short Circuit Current)</span>
                                    <span class="text-2xl font-bold text-red-400">${(I_sc/1000).toFixed(2)} kA</span>
                                    <span class="text-gray-300 text-xs block mt-1">標么值計算 (Per Unit Method)</span>
                                </div>`;
                        }
                        } // 結束 is3Ph 判斷
                    } else {
                        dropLog.innerHTML = '<div class="text-gray-400 text-center p-4"><i class="fa-solid fa-calculator text-2xl mb-2 block"></i>請輸入規劃總容量以開始計算...</div>';
                        scLog.innerHTML = '<div class="text-gray-400 text-center p-4"><i class="fa-solid fa-burst text-2xl mb-2 block"></i>請輸入規劃總容量以開始計算...</div>';
                    }
                    
                    // 2. String Planning Calculation
                    App.calc.calculateStringPlanning();
                },

                // --- 核心：串列規劃演算法 ---
                calculateStringPlanning: () => {
                    const resDiv = document.getElementById('planningResults');
                    const modIdx = document.getElementById('activeModuleSelect').value;
                    const rows = document.querySelectorAll('#inverterListBody tr');
                    const roofs = App.ui.getRoofList();
                    const roofCount = Math.max(1, roofs.length);
                    
                    if(modIdx === "" || rows.length === 0) {
                        resDiv.innerHTML = `<div class="text-center text-gray-400 p-8 border-2 border-dashed rounded-lg col-span-full">請先選擇模組並配置逆變器...</div>`;
                        return;
                    }

                    const mod = App.cache.modules[modIdx];
                    if (!mod) {
                        resDiv.innerHTML = `<div class="text-center text-red-400 p-8 border-2 border-dashed rounded-lg col-span-full">模組資料錯誤，請重新選擇...</div>`;
                        return;
                    }
                    
                    // Display Module Specs
                    document.getElementById('moduleSpecsDisplay').innerHTML = 
                        `Voc: ${mod.v_oc}V | Vmp: ${mod.v_mp || mod.v_oc * 0.85}V | Isc: ${mod.i_sc}A | Pmax: ${mod.p_max}W`;

                    // 獲取使用者輸入的總規劃片數
                    const plannedPanelsTotal = parseInt(document.getElementById('plannedPanels').value || 0);
                    
                    if (plannedPanelsTotal <= 0) {
                        resDiv.innerHTML = `<div class="text-center text-gray-400 p-8 border-2 border-dashed rounded-lg col-span-full">請輸入規劃片數以開始規劃...</div>`;
                        return;
                    }
                    
                    // 計算所有逆變器的總功率和容量限制
                    let totalInverterPower = 0;
                    const inverterConfigs = [];
                    
                    rows.forEach((tr) => {
                        const sel = tr.querySelector('select');
                        const ratioInput = tr.querySelectorAll('input')[0];
                        const qtyInput = tr.querySelectorAll('input')[1];
                        
                        if(!sel || !sel.value) return;
                        const inv = App.cache.inverters[sel.value];
                        if (!inv) return;
                        
                        const ratio = parseFloat(ratioInput.value) / 100 || 1.2;
                        const qty = parseInt(qtyInput.value) || 1;
                        const powerPerUnit = inv.rated_output_power_kw * ratio;
                        const totalPower = powerPerUnit * qty;
                        
                        // 計算每台逆變器的最大片數容量
                        // 容量 = (額定功率 * 超配比) / 單片模組功率
                        const maxCapacityKw = inv.rated_output_power_kw * ratio;
                        const maxPanelsPerUnit = Math.floor(maxCapacityKw * 1000 / mod.p_max);
                        const totalMaxPanels = maxPanelsPerUnit * qty;
                        
                        totalInverterPower += totalPower;
                        
                        // 我們這裡把多台同型號拆開處理嗎？不，保持 qty 結構，但在分配時要注意
                        // 為了精確分配，最好將每台逆變器視為獨立個體，但目前架構是 grouped by model
                        // 我們將在後面分配時處理 totalMaxPanels
                        
                        inverterConfigs.push({
                            inv: inv,
                            ratio: ratio,
                            qty: qty,
                            powerPerUnit: powerPerUnit,
                            totalPower: totalPower,
                            maxPanelsPerUnit: maxPanelsPerUnit, // 單台最大片數
                            totalMaxPanels: totalMaxPanels,     // 該組總最大片數
                            assignedPanels: 0,                  // 預計分配片數
                            sel: sel,
                            ratioInput: ratioInput,
                            qtyInput: qtyInput
                        });
                    });
                    
                    if (inverterConfigs.length === 0 || totalInverterPower === 0) {
                        resDiv.innerHTML = `<div class="text-center text-gray-400 p-8 border-2 border-dashed rounded-lg col-span-full">請配置有效的逆變器...</div>`;
                        return;
                    }
                    
                    // --- 智慧分配片數邏輯 (Smart Panel Distribution) ---
                    // 1. 初步按功率比例分配
                    // 2. 檢查每組是否超過容量上限 (Ceiling)
                    // 3. 將溢出的片數重新分配給還有空間的逆變器 (Overflow Handling)
                    
                    let remainingToAssign = plannedPanelsTotal;
                    
                    // 步驟 1: 按比例分配 (Proportional Distribution)
                    inverterConfigs.forEach(config => {
                        const share = config.totalPower / totalInverterPower;
                        let assign = Math.round(plannedPanelsTotal * share);
                        config.assignedPanels = assign;
                    });
                    
                    // 修正四捨五入誤差
                    let currentAssignedTotal = inverterConfigs.reduce((sum, c) => sum + c.assignedPanels, 0);
                    let diff = plannedPanelsTotal - currentAssignedTotal;
                    if (diff !== 0) {
                        // 將差額加到最後一個，或者是容量最大的？簡單加到最後一個
                        inverterConfigs[inverterConfigs.length - 1].assignedPanels += diff;
                    }
                    
                    // 步驟 2 & 3: 容量檢查與溢出處理 (Capacity Check & Overflow)
                    // 多次迭代以確保溢出被消化
                    let hasOverflow = true;
                    let iteration = 0;
                    while (hasOverflow && iteration < 5) {
                        hasOverflow = false;
                        let totalOverflow = 0;
                        
                        // 檢查溢出
                        inverterConfigs.forEach(config => {
                            if (config.assignedPanels > config.totalMaxPanels) {
                                const overflow = config.assignedPanels - config.totalMaxPanels;
                                config.assignedPanels = config.totalMaxPanels;
                                totalOverflow += overflow;
                                hasOverflow = true;
                            }
                        });
                        
                        if (totalOverflow > 0) {
                            // 尋找還有空間的逆變器
                            const capableInverters = inverterConfigs.filter(c => c.assignedPanels < c.totalMaxPanels);
                            
                            if (capableInverters.length > 0) {
                                // 將溢出量平均分配給有空間的
                                // 或者按剩餘空間比例分配？簡單平均分配即可
                                const avgOverflow = Math.floor(totalOverflow / capableInverters.length);
                                let remainder = totalOverflow % capableInverters.length;
                                
                                capableInverters.forEach(config => {
                                    const space = config.totalMaxPanels - config.assignedPanels;
                                    const toAdd = Math.min(space, avgOverflow + (remainder > 0 ? 1 : 0));
                                    config.assignedPanels += toAdd;
                                    totalOverflow -= toAdd;
                                    if (remainder > 0) remainder--;
                                });
                            }
                            
                            // 如果還有剩餘 (所有逆變器都滿了)，則強制加回去 (顯示錯誤)
                            // 這種情況下，我們會違反 Ceiling，但在內部 MPPT 邏輯會顯示錯誤
                            if (totalOverflow > 0) {
                                // 加回給最後一個，讓它報錯
                                inverterConfigs[inverterConfigs.length - 1].assignedPanels += totalOverflow;
                                hasOverflow = false; // 停止迭代
                            }
                        }
                        iteration++;
                    }

                    
                    let html = '';
                    App.reportData.planning = []; // Clear old report
                    let totalAssignedAll = 0; // 追蹤所有逆變器分配的總片數
  
                    inverterConfigs.forEach((config, idx) => {
                        const inv = config.inv;
                        const ratio = config.ratio;
                        const qty = config.qty;
                        
                        // 使用預先分配好的片數
                        let targetPanelsTotal = config.assignedPanels;
                        
                        // 確保分配片數永遠為正數（不小於0）
                        targetPanelsTotal = Math.max(0, targetPanelsTotal);
                        
                        totalAssignedAll += targetPanelsTotal;
                        
                        // 詳細的溫度係數計算（0~75度C）
                        // 使用標準溫度係數（如果模組資料庫沒有提供）
                        const T_min = 0; // 最低工作溫度（更保守）
                        const T_max = 75; // 最高工作溫度
                        const T_stc = 25; // 標準測試條件溫度
                        
                        // 溫度係數（%/°C）- 如果模組資料庫有提供則使用，否則使用典型值
                        const coef_Voc = mod.temp_coef_voc ? parseFloat(mod.temp_coef_voc) / 100 : -0.28 / 100; // Voc溫度係數
                        const coef_Vmp = mod.temp_coef_vmp ? parseFloat(mod.temp_coef_vmp) / 100 : -0.35 / 100; // Vmp溫度係數
                        const coef_Isc = mod.temp_coef_isc ? parseFloat(mod.temp_coef_isc) / 100 : 0.05 / 100; // Isc溫度係數
                        
                        // 計算不同溫度下的電壓
                        // 低溫時（0°C）：Voc增加，用於檢查系統最大電壓
                        const V_oc_min_temp = mod.v_oc * (1 + coef_Voc * (T_min - T_stc));
                        // 高溫時（75°C）：Vmp降低，用於檢查MPPT追蹤範圍
                        const V_mp_max_temp = (mod.v_mp || mod.v_oc * 0.85) * (1 + coef_Vmp * (T_max - T_stc));
                        // 標準條件下的Vmp
                        const V_mp_stc = mod.v_mp || mod.v_oc * 0.85;
                        
                        // 系統最大電壓限制（0°C時，使用Voc）
                        const V_max_possible = V_oc_min_temp; // 0°C時的Voc
                        // MPPT追蹤範圍檢查（75°C時，使用Vmp）
                        const V_min_possible = V_mp_max_temp; // 75°C時的Vmp

                        // 解析 MPPT 電壓範圍，處理 NaN 問題
                        let mppt_range = [200, 800]; // 預設值
                        if (inv.mppt_voltage_range_v) {
                            const rangeStr = String(inv.mppt_voltage_range_v).trim();
                            if (rangeStr.includes('-')) {
                                const parts = rangeStr.split('-').map(s => {
                                    const num = parseFloat(s.trim());
                                    return isNaN(num) ? null : num;
                                });
                                if (parts[0] !== null && parts[1] !== null) {
                                    mppt_range = [parts[0], parts[1]];
                                } else if (parts[0] !== null) {
                                    mppt_range = [parts[0], parts[0] * 2]; // 如果只有最小值，估算最大值
                                }
                            } else {
                                const num = parseFloat(rangeStr);
                                if (!isNaN(num)) {
                                    mppt_range = [num, num * 2]; // 單一值時估算範圍
                                }
                            }
                        }
                        const mppt_min = mppt_range[0];
                        const mppt_max = mppt_range[1];
                        
                        // 計算串列限制（根據使用者定義的三大優先權）
                        
                        // 計算 Vmp 在最低溫 (0°C) 的值，用於 MPPT 上限檢查
                        const V_mp_min_temp = V_mp_stc * (1 + coef_Vmp * (T_min - T_stc));

                        // 1. 第一優先：最大輸入電壓 (Max Input Voltage) - 硬性安全限制
                        // 條件：Voc(0°C) <= Max Input Voltage
                        const N_safety_max = Math.floor(inv.max_input_voltage_v / V_max_possible); 

                        // 2. 第二優先：MPPT 追蹤範圍 (MPPT Voltage Range) - 有效工作範圍
                        // 條件：Vmp 必須全程落在 [MPPT_min, MPPT_max]
                        // 下限：Vmp(75°C) >= MPPT_min
                        const N_mppt_min = Math.ceil(mppt_min / V_min_possible);
                        // 上限：Vmp(0°C) <= MPPT_max
                        const N_mppt_max = Math.floor(mppt_max / V_mp_min_temp);

                        // 綜合限制範圍
                        const limit_str_min = Math.max(N_mppt_min, 1);
                        // MPPT 上限與安全上限取交集，但安全上限是絕對的
                        // 如果 MPPT 上限低於安全上限，我們應該儘量遵守 MPPT 上限，但在某些極端情況下（如為了湊數），安全上限是最後底線。
                        // 但根據規則 "Vmp 必須全程在此範圍內"，我們應該嚴格遵守交集。
                        const limit_str_max_final = Math.min(N_safety_max, N_mppt_max);
                        
                        // 確保最小限制不超過最大限制 (如果發生，表示該模組無法匹配此逆變器)
                        // 在此情況下，我們放寬 MPPT 上限，但絕不放寬安全上限
                        let valid_range_max = limit_str_max_final;
                        if (limit_str_min > valid_range_max) {
                             if (limit_str_min <= N_safety_max) {
                                 // 放寬 MPPT 上限要求，以允許至少能配置
                                 valid_range_max = N_safety_max;
                                 console.warn(`MPPT 範圍過窄，放寬上限至安全極限: ${N_safety_max}`);
                             } else {
                                 // 連安全限制都無法滿足
                                 valid_range_max = 0; 
                             }
                        }

                        // 3. 第三優先：額定工作電壓 (Rated Operating Voltage) - 最佳化目標
                        // 目標：Vmp 接近 Rated Voltage
                        const rated_vol = inv.rated_input_voltage_v || (mppt_min + mppt_max) / 2;
                        const N_opt = Math.round(rated_vol / V_mp_stc);

                        // 為了相容後續代碼，保留變數名稱
                        const Nmax = N_safety_max;
                        const Nmin = N_mppt_min;
                        const limit_str_max_mppt_final = valid_range_max;
                        // 注意：這裡我們移除了 "Nmax - 1" 的保守減一，因為新的邏輯更精確，且使用者要求 "最大輸入電壓" 為邊界。
                        // 若需要保守，可自行在 N_safety_max 減一，但通常 floor(Voc) 已經是整數邊界。


                        // 改進的規劃邏輯：優先讓每一串列都在MPPT追蹤範圍內，不強制每個MPPT都使用
                        // 電流檢核：計算每串列的電流（使用最大功率點電流 I_mp）
                        let I_string = mod.i_mp; // 使用最大功率點電流
                        if (!I_string || I_string === 0) {
                            // 如果沒有 I_mp 資料，嘗試從功率計算：I_mp ≈ P_max / V_mp
                            const V_mp = mod.v_mp || mod.v_oc * 0.85;
                            I_string = (mod.p_max / 1000) / V_mp; // 轉換為 A
                            console.warn(`模組 ${mod.model_number} 缺少 I_mp 資料，使用計算值: ${I_string.toFixed(2)}A`);
                        }
                        
                        // 提取 MPPT 最大電流數值（處理不同格式）
                        // 定義：一般情況下「MPPT最大電流」指「每一個 MPPT 的最大電流」。
                        // - 若 MPPT > 1：優先使用每 MPPT 欄位；僅在缺資料或特定機型（如 M125HV）時，才用「總電流 ÷ MPPT數」推回每 MPPT。
                        // - 若 MPPT = 1：每 MPPT 最大電流 = 該 MPPT 最大電流（可直接用每 MPPT 欄位或總電流欄位）。
                        let maxCurrentPerMPPT = null; // 若無有效資料則為 null
                        const mpptCount = parseInt(inv.num_mpp_trackers || 0) || 0;
                        const isM125HV = /m125hv/i.test(String(inv.model_name || '')) || /m125hv/i.test(String(inv.series || ''));
                        
                        const parseCurrent = (value, maxAllowed) => {
                            if (value === null || value === undefined || value === '') return null;
                            if (typeof value === 'number') {
                                if (!isNaN(value) && value > 0 && value <= maxAllowed) return value;
                                return null;
                            }
                            const s = String(value).trim();
                            if (s.includes('999') || s.toLowerCase().includes('na') || s.toLowerCase().includes('n/a')) return null;
                            const m = s.match(/^[\d.]+/);
                            if (!m) return null;
                            const num = parseFloat(m[0]);
                            if (!isNaN(num) && num > 0 && num <= maxAllowed) return num;
                            return null;
                        };
                        
                        // 候選欄位：總電流與每MPPT電流
                        const totalCurrentField = inv.max_input_current_total_a || inv.max_input_current_total ||
                                                 inv['Max Input Current Total A'] || inv['max_input_current_total_a'];
                        const totalCurrent = parseCurrent(totalCurrentField, 1000); // 總電流可能較大
                        const perMpptCurrent = parseCurrent(inv.max_input_current_per_mppt_a, 100); // 每MPPT通常 <= 100A
                        
                        if (mpptCount <= 1) {
                            // MPPT=1：每MPPT最大電流 = 該MPPT最大電流（per-mppt 欄位優先，其次總電流欄位）
                            maxCurrentPerMPPT = perMpptCurrent !== null ? perMpptCurrent : (totalCurrent !== null ? totalCurrent : null);
                        } else {
                            // MPPT>1：一般優先 per-mppt 欄位；若是 M125HV 或 per-mppt 缺資料，才用總電流÷MPPT
                            if (!isM125HV && perMpptCurrent !== null) {
                                maxCurrentPerMPPT = perMpptCurrent;
                            } else if (totalCurrent !== null) {
                                maxCurrentPerMPPT = totalCurrent / mpptCount;
                                console.log(`逆變器 ${inv.model_name} 使用總電流 ${totalCurrent}A ÷ ${mpptCount} MPPT = ${maxCurrentPerMPPT.toFixed(2)}A/MPPT`);
                            } else if (perMpptCurrent !== null) {
                                // 沒有總電流但有 per-mppt（即便是 M125HV 也退而求其次）
                                maxCurrentPerMPPT = perMpptCurrent;
                            } else {
                                maxCurrentPerMPPT = null;
                            }
                        }
                        
                        // 如果沒有有效的MPPT最大電流值，標記為需要檢查
                        if (maxCurrentPerMPPT === null) {
                            console.warn(`逆變器 ${inv.model_name} 缺少有效的 MPPT 最大電流資料，總電流: ${totalCurrentField}, 每MPPT電流: ${inv.max_input_current_per_mppt_a}`);
                            // 不設置預設值，讓顯示邏輯處理
                            maxCurrentPerMPPT = null;
                        }
                        
                        // 計算最大並聯串數：MPPT最大電流 / 模組最大電流（I_mp）
                        // 如果沒有有效的MPPT最大電流值，使用保守估計
                        // 並聯數電流容許：MPPT最大電流 +5% buffer
                        const CURRENT_BUFFER_FACTOR = 1.05;
                        const effectiveMaxCurrent = maxCurrentPerMPPT !== null ? (maxCurrentPerMPPT * CURRENT_BUFFER_FACTOR) : 30; // 保守預設值用於計算
                        const maxParallelStrings = I_string > 0 ? Math.floor(effectiveMaxCurrent / I_string) : 1;
                        const finalMaxParallelStrings = maxParallelStrings > 0 ? maxParallelStrings : 1;
                        
                        // 計算每串列的最佳片數 (Priority 3: Rated Operating Voltage)
                        let optimalPanelsPerString = N_opt;
                        optimalPanelsPerString = Math.max(limit_str_min, Math.min(optimalPanelsPerString, limit_str_max_mppt_final));
                        
                        // 如果最佳片數不在範圍內，使用範圍內的最大值（盡可能接近MPPT最大值）
                        if (optimalPanelsPerString < limit_str_min) {
                            optimalPanelsPerString = limit_str_min;
                        } else if (optimalPanelsPerString > limit_str_max_mppt_final) {
                            optimalPanelsPerString = limit_str_max_mppt_final;
                        }
                        
                        // 計算可以配置多少個符合要求的串列（在MPPT範圍內）
                        const panelsPerString = optimalPanelsPerString;
                        const maxStringsPossible = Math.floor(targetPanelsTotal / panelsPerString);
                        
                        // 計算需要多少個MPPT來配置這些串列（用於MPPT數量大於1的情況）
                        // 每個MPPT最多可以配置 finalMaxParallelStrings 串
                        const maxMPPTsToUse = maxStringsPossible > 0 
                            ? Math.min(inv.num_mpp_trackers, Math.ceil(maxStringsPossible / finalMaxParallelStrings))
                            : 0;
                        
                        // 特殊處理：當MPPT數量只有1時，優先考慮串列相等且在工作電壓範圍內
                        let actualStringsPerMPPT = 0;
                        let actualPanelsPerString = panelsPerString;
                        let actualMPPTsToUse = maxMPPTsToUse;
                        
                        if (inv.num_mpp_trackers === 1) {
                            // MPPT數量為1時的特殊邏輯：
                            // 1. 優先考慮每條串列相等
                            // 2. 優先考慮串列能夠在工作電壓範圍裡（0°C不超過系統耐壓，75°C在MPPT範圍內）
                            // 3. 後續再考慮這些串列能夠在MPPT工作電壓裡運作
                            
                            // 計算在電壓範圍內的最大串數（考慮並聯限制）
                            // 工作電壓範圍：0°C時不超過系統耐壓，75°C時在MPPT範圍內
                            const maxPanelsPerString_Voltage = Math.min(
                                Math.floor(inv.max_input_voltage_v / V_oc_min_temp), // 0°C系統耐壓限制
                                Math.floor(mppt_max / V_mp_max_temp) // 75°C MPPT最大值限制
                            );
                            const minPanelsPerString_Voltage = Math.ceil(mppt_min / V_mp_max_temp); // 75°C MPPT最小值限制
                            
                            // 在電壓範圍內，尋找能夠整除目標片數的串列配置
                            // 優先考慮每串列相等
                            let bestConfig = null;
                            let bestScore = -1;
                            
                            // 嘗試不同的串數（從1到最大並聯數）
                            for (let numStrings = 1; numStrings <= finalMaxParallelStrings; numStrings++) {
                                const panelsPerString_try = Math.floor(targetPanelsTotal / numStrings);
                                const remainder = targetPanelsTotal % numStrings;
                                
                                // 如果無法整除，跳過（優先考慮每串列相等）
                                if (remainder !== 0) continue;
                                
                                // 檢查是否在電壓範圍內
                                if (panelsPerString_try >= minPanelsPerString_Voltage && 
                                    panelsPerString_try <= maxPanelsPerString_Voltage &&
                                    panelsPerString_try >= limit_str_min &&
                                    panelsPerString_try <= Nmax) {
                                    
                                    // 計算評分：優先考慮在MPPT工作電壓範圍內（75°C時）
                                    const V_75C = panelsPerString_try * V_mp_max_temp;
                                    const inMPPTRange = V_75C >= mppt_min && V_75C <= mppt_max;
                                    const score = inMPPTRange ? 1000 + (mppt_max - V_75C) : (V_75C - mppt_min); // 在範圍內得分更高
                                    
                                    if (score > bestScore) {
                                        bestScore = score;
                                        bestConfig = {
                                            strings: numStrings,
                                            panelsPerString: panelsPerString_try
                                        };
                                    }
                                }
                            }
                            
                            if (bestConfig) {
                                // 找到最佳配置
                                actualStringsPerMPPT = bestConfig.strings;
                                actualPanelsPerString = bestConfig.panelsPerString;
                                actualMPPTsToUse = 1;
                            } else {
                                // 如果找不到完全相等的配置，嘗試最接近的配置
                                // 優先考慮在電壓範圍內
                                const optimalPanels = Math.min(
                                    Math.floor(targetPanelsTotal / finalMaxParallelStrings),
                                    maxPanelsPerString_Voltage
                                );
                                actualPanelsPerString = Math.max(optimalPanels, minPanelsPerString_Voltage);
                                actualStringsPerMPPT = Math.ceil(targetPanelsTotal / actualPanelsPerString);
                                actualStringsPerMPPT = Math.min(actualStringsPerMPPT, finalMaxParallelStrings);
                                actualMPPTsToUse = 1;
                            }
                        } else {
                            // MPPT數量大於1時，使用原有邏輯
                            // 智能分配策略：優先配置符合要求的串列，不強制使用所有MPPT
                            // maxStringsPossible 和 maxMPPTsToUse 已在上面定義
                            actualMPPTsToUse = maxMPPTsToUse;
                            
                            if (maxStringsPossible === 0 || actualMPPTsToUse === 0) {
                                // 片數不足以配置符合要求的串列，嘗試其他方案
                                if (targetPanelsTotal > limit_str_max_mppt_final) {
                                    // 總片數超過最大限制：必須並聯，不能超過
                                    const tryPanelsPerString = Math.floor(targetPanelsTotal / finalMaxParallelStrings);
                                    // 確保每串不超過最大限制（考慮0°C系統耐壓和75°C MPPT範圍）
                                    actualPanelsPerString = Math.min(tryPanelsPerString, limit_str_max_mppt_final);
                                    actualStringsPerMPPT = Math.ceil(targetPanelsTotal / actualPanelsPerString);
                                    actualStringsPerMPPT = Math.min(actualStringsPerMPPT, finalMaxParallelStrings);
                                    actualMPPTsToUse = 1;
                                } else {
                                    // 總片數在最大限制內：可以接受（即使小於最小限制也可以）
                                    actualPanelsPerString = targetPanelsTotal;
                                    actualStringsPerMPPT = 1;
                                    actualMPPTsToUse = 1;
                                }
                            } else {
                                // 可以配置符合要求的串列
                                // 優先集中在少數MPPT並聯到最大組數
                                const totalStringsNeeded = maxStringsPossible;
                                
                                // 計算需要多少個MPPT才能分配完所有串數
                                // 優先填滿前面的MPPT到最大並聯數
                                actualMPPTsToUse = Math.min(
                                    inv.num_mpp_trackers,
                                    Math.ceil(totalStringsNeeded / finalMaxParallelStrings)
                                );
                                
                                // 計算每個MPPT應該配置多少串（優先填滿到最大並聯數）
                                actualStringsPerMPPT = Math.min(
                                    Math.ceil(totalStringsNeeded / actualMPPTsToUse),
                                    finalMaxParallelStrings
                                );
                                
                                // 確保每個MPPT至少配置1串
                                if (actualStringsPerMPPT === 0) {
                                    actualStringsPerMPPT = 1;
                                }
                            }
                        }
                        
                        // ========== 重新設計的MPPT分配邏輯 ==========
                        // 使用貪心算法，逐個MPPT分配片數，確保所有片數都被分配
                        
                        let mpptHtml = '';
                        let planDetails = [];
                        let totalAssigned = 0;
                        let remainingPanels = targetPanelsTotal; // 剩餘待分配的片數
                        
                        // ========== 重新設計的MPPT分配邏輯 ==========
                        // 優先順序：
                        // 1. 先檢核分配的數量是否超過該逆變器總容量*超配比
                        // 2. 每一mppt能並多少串列取決於每一串最大電流與mppt最大輸入電流
                        // 3. 如果有殘餘片數，則使用疊代的方式重新分配所有mppt做檢核
                        
                        // 步驟1：檢核總容量限制
                        const inverterMaxCapacity = inv.rated_output_power_kw * ratio * qty; // 逆變器總容量 * 超配比 * 數量
                        const targetPower = targetPanelsTotal * mod.p_max / 1000; // 目標片數對應的功率 (kW)
                        
                        if (targetPower > inverterMaxCapacity) {
                            // 超過容量限制，不應該繼續分配
                            mpptHtml = `
                                <div class="mt-2 p-4 bg-red-50 border-2 border-red-300 rounded-lg text-sm text-red-800">
                                    <div class="flex items-start">
                                        <i class="fa-solid fa-exclamation-circle mr-2 mt-0.5 text-red-600"></i>
                                        <div>
                                            <div class="font-bold mb-1">超過逆變器容量限制</div>
                                            <div>規劃片數對應功率: <strong>${targetPower.toFixed(2)} kW</strong></div>
                                            <div>逆變器最大容量 (含超配比): <strong>${inverterMaxCapacity.toFixed(2)} kW</strong></div>
                                            <div class="mt-2 text-xs text-red-700">
                                                <strong>建議：</strong>請新增一台逆變器或調整DC/AC超配比
                                            </div>
                                        </div>
                                    </div>
                                </div>`;
                            
                            // 不繼續分配，直接返回
                            totalAssigned = 0;
                            remainingPanels = targetPanelsTotal;
                        } else {
                            // 步驟2和3：使用「最佳組合搜尋演算法 (Best Fit Partition Search)」
                            // 放棄貪婪法，改用全域搜尋
                            // 演算法目標：將總片數 targetPanelsTotal 拆解成 S 串，分配到 MPPT 中
                            
                            // 定義變數
                            let bestPlan = null;
                            let bestScore = -Infinity;
                            let bestRemaining = targetPanelsTotal;
                            
                            // 計算最大的可能總串數 (所有MPPT都插滿)
                            // 每一MPPT能並多少串列取決於每一串最大電流與MPPT最大輸入電流
                            const CURRENT_BUFFER_FACTOR = 1.05;
                            const maxStringsPerMPPT = Math.floor(((maxCurrentPerMPPT ?? 0) * CURRENT_BUFFER_FACTOR) / I_string);
                            
                            // 如果連1串都不能放（電流限制），那就沒戲唱了
                            if (maxStringsPerMPPT > 0) {
                                const maxTotalStringsPossible = inv.num_mpp_trackers * maxStringsPerMPPT;
                                
                                // 搜尋空間：嘗試不同的總串數 S
                                // S 的下限：必須能容納總片數，且每串不超過最大片數限制
                                const minTotalStrings = Math.ceil(targetPanelsTotal / limit_str_max_mppt_final);
                                // S 的上限：受限於MPPT最大可並聯總數，且每串至少要達到最小片數限制
                                const maxS_by_min_panels = Math.floor(targetPanelsTotal / limit_str_min);
                                const searchEnd = Math.min(maxTotalStringsPossible, maxS_by_min_panels);
                                const searchStart = Math.max(1, minTotalStrings);

                                for (let S = searchStart; S <= searchEnd; S++) {
                                    // 嘗試將 targetPanelsTotal 拆成 S 串
                                    // 計算平均片數
                                    const avgPanels = targetPanelsTotal / S;
                                    
                                    // 基礎片數 L (Base Length)
                                    const L = Math.floor(avgPanels);
                                    // 餘數 R (Remainder)，代表有 R 串是 L+1 片，(S-R) 串是 L 片
                                    const R = targetPanelsTotal % S;
                                    
                                    const len_A = L + 1;
                                    const count_A = R;
                                    
                                    const len_B = L;
                                    const count_B = S - R;
                                    
                                    // 檢查片數是否在允許範圍內 [limit_str_min, limit_str_max_mppt_final]
                                    // 注意：如果 count 為 0，則該長度不需要檢查
                                    let validA = true;
                                    if (count_A > 0) {
                                        if (len_A < limit_str_min || len_A > limit_str_max_mppt_final) validA = false;
                                    }
                                    
                                    let validB = true;
                                    if (count_B > 0) {
                                        if (len_B < limit_str_min || len_B > limit_str_max_mppt_final) validB = false;
                                    }
                                    
                                    if (!validA || !validB) continue; // 片數不合規，換下一個 S
                                    
                                    // 檢查是否能分配到 MPPT (硬體限制：同 MPPT 同電壓)
                                    // 我們需要 MPPTs_needed_A 個 MPPT 給 A 群組，MPPTs_needed_B 個 MPPT 給 B 群組
                                    // 這裡計算「最少」需要的 MPPT 數量
                                    const min_MPPTs_needed_A = Math.ceil(count_A / maxStringsPerMPPT);
                                    const min_MPPTs_needed_B = Math.ceil(count_B / maxStringsPerMPPT);
                                    
                                    const total_min_MPPTs_needed = min_MPPTs_needed_A + min_MPPTs_needed_B;
                                    
                                    if (total_min_MPPTs_needed > inv.num_mpp_trackers) continue; // MPPT 不夠分，換下一個 S
                                    
                                    // --- 找到一個可行解 ---
                                    
                                    // 構建 Plan 物件
                                    let currentPlan = [];
                                    let mppt_index = 1;
                                    
                                    // 優化分配策略：
                                    // 雖然我們只需要 min_MPPTs_needed，但如果有額外的 MPPT，我們應該利用它們來平均分配串列
                                    // 這樣可以降低每個 MPPT 的負載，提高散熱和壽命 (Priority 3: MPPT Balance)
                                    
                                    // 分配邏輯：
                                    // 1. 決定 Group A 和 Group B 各自分配多少個 MPPT
                                    // 這裡簡單起見，我們按比例分配剩餘的 MPPT，或者只使用最少需要的 MPPT
                                    // 根據「優先充分利用所有可用的 MPPT」原則，我們應該嘗試使用更多 MPPT
                                    // 但要遵守「同 MPPT 同電壓」，所以 MPPT 必須專屬於 A 或 B
                                    
                                    // 計算可用的額外 MPPT
                                    let extra_MPPTs = inv.num_mpp_trackers - total_min_MPPTs_needed;
                                    let allocated_MPPTs_A = min_MPPTs_needed_A;
                                    let allocated_MPPTs_B = min_MPPTs_needed_B;
                                    
                                    // 簡單分配額外 MPPT：優先給串數多的群組，或者平均分配
                                    // 這裡使用簡單循環分配
                                    while (extra_MPPTs > 0) {
                                        // 比較 A 和 B 的平均每 MPPT 串數，優先給密度高的
                                        const density_A = allocated_MPPTs_A > 0 ? count_A / allocated_MPPTs_A : 0;
                                        const density_B = allocated_MPPTs_B > 0 ? count_B / allocated_MPPTs_B : 0;
                                        
                                        if (density_A >= density_B && count_A > allocated_MPPTs_A) { // 確保不超過每 MPPT 1 串的極限
                                            allocated_MPPTs_A++;
                                            extra_MPPTs--;
                                        } else if (count_B > allocated_MPPTs_B) {
                                            allocated_MPPTs_B++;
                                            extra_MPPTs--;
                                        } else {
                                            break; // 都已經分散到每 MPPT 1 串了，不需要再分
                                        }
                                    }
                                    
                                    // 執行分配 - Group A
                                    // 將 count_A 串平均分配到 allocated_MPPTs_A 個 MPPT
                                    if (count_A > 0) {
                                        const base_str_A = Math.floor(count_A / allocated_MPPTs_A);
                                        const rem_str_A = count_A % allocated_MPPTs_A;
                                        
                                        for (let i = 0; i < allocated_MPPTs_A; i++) {
                                            const strings_for_this_mppt = (i < rem_str_A) ? base_str_A + 1 : base_str_A;
                                            currentPlan.push({
                                                mpptIndex: mppt_index,
                                                strings: strings_for_this_mppt,
                                                panelsPerString: len_A,
                                                panels: strings_for_this_mppt * len_A,
                                                group: 'A'
                                            });
                                            mppt_index++;
                                        }
                                    }
                                    
                                    // 執行分配 - Group B
                                    if (count_B > 0) {
                                        const base_str_B = Math.floor(count_B / allocated_MPPTs_B);
                                        const rem_str_B = count_B % allocated_MPPTs_B;
                                        
                                        for (let i = 0; i < allocated_MPPTs_B; i++) {
                                            const strings_for_this_mppt = (i < rem_str_B) ? base_str_B + 1 : base_str_B;
                                            currentPlan.push({
                                                mpptIndex: mppt_index,
                                                strings: strings_for_this_mppt,
                                                panelsPerString: len_B,
                                                panels: strings_for_this_mppt * len_B,
                                                group: 'B'
                                            });
                                            mppt_index++;
                                        }
                                    }
                                    
                                    // 計算分數
                                    // 優先級 1: 無殘餘片數 (此演算法本質上保證無殘餘)
                                    // 優先級 2: 使用最少的串數 (S 越小越好 => 電壓越高)
                                    // 優先級 3: MPPT 使用平衡 (變異數越小越好? 或者只是盡量用?)
                                    
                                    let score = 0;
                                    
                                    // Base score for finding a valid solution (Residual = 0)
                                    score += 1000000;
                                    
                                    // Minimize S (Maximize Voltage)
                                    // S 越小，分數越高。用 maxTotalStringsPossible - S 來加分
                                    score += (maxTotalStringsPossible - S) * 1000;
                                    
                                    // MPPT Balance Score
                                    // 這裡分數加上使用的 MPPT 總數，鼓勵分散
                                    const total_MPPTs_used = allocated_MPPTs_A + allocated_MPPTs_B;
                                    score += total_MPPTs_used * 10;
                                    
                                    // 額外加分：如果分配非常均勻 (例如每 MPPT 串數都一樣)
                                    // 計算串數的標準差? 太複雜，簡單判斷
                                    // 如果 count_A 和 count_B 能被 allocated MPPTs 整除，加分
                                    if (count_A % allocated_MPPTs_A === 0 && (count_B === 0 || count_B % allocated_MPPTs_B === 0)) {
                                        score += 5;
                                    }

                                    if (score > bestScore) {
                                        bestScore = score;
                                        bestPlan = currentPlan;
                                        bestRemaining = 0; // 此算法若成功，必無殘餘
                                    }
                                }
                            }

                            // 如果找不到無殘餘的完美解 (bestPlan仍為null)，則退回到「盡量填滿」的邏輯
                            // 但為了簡化，若找不到完美解，我們嘗試尋找「殘餘最少」的解
                            // 這裡透過放寬 R 的限制來模擬 (允許 R 個片數不被分配)
                            if (!bestPlan) {
                                // Fallback: Iterate S and allow remaining panels
                                let fallbackScore = -Infinity;
                                
                                for (let S = 1; S <= inv.num_mpp_trackers * maxStringsPerMPPT; S++) {
                                     // 嘗試只分配 target - remainder 片
                                     const avg = targetPanelsTotal / S;
                                     let L = Math.floor(avg);
                                     
                                     // 確保 L 在範圍內
                                     if (L > limit_str_max_mppt_final) L = limit_str_max_mppt_final;
                                     if (L < limit_str_min) continue; 
                                     
                                     // 假設所有 S 串都是長度 L
                                     const allocated = S * L;
                                     const remainder = targetPanelsTotal - allocated;
                                     
                                     if (remainder < 0) continue; 
                                     
                                     // 檢查 MPPT 容量
                                     const needed = Math.ceil(S / maxStringsPerMPPT);
                                     if (needed > inv.num_mpp_trackers) continue;
                                     
                                     let score = allocated * 100; // 越多越好
                                     score -= S; // 串數越少越好
                                     
                                     if (score > fallbackScore) {
                                         fallbackScore = score;
                                         bestRemaining = remainder;
                                         
                                         // 建構 fallback plan (簡單均分)
                                         bestPlan = [];
                                         let strings_rem = S;
                                         let m_idx = 1;
                                         const mppts_needed = needed; // 使用最少需要的 MPPT
                                         
                                         const base_str = Math.floor(S / mppts_needed);
                                         const rem_str = S % mppts_needed;
                                         
                                         for(let i=0; i<mppts_needed; i++) {
                                             const str = (i < rem_str) ? base_str + 1 : base_str;
                                             bestPlan.push({
                                                 mpptIndex: m_idx++,
                                                 strings: str,
                                                 panelsPerString: L,
                                                 panels: str * L,
                                                 group: 'Fallback'
                                             });
                                         }
                                     }
                                }
                            }
                            
                            // 使用最佳方案進行分配
                            if (bestPlan) {
                                // bestPlan 中的 mpptIndex 是 1-based，且可能不連續或亂序 (因為我們分了 A/B 群)
                                // 我們需要將其映射到實際的 MPPT 1..N
                                
                                // 重置 MPPT html
                                // 但要注意，外部已經有 mpptHtml 變數
                                
                                // 建立一個 map 來儲存每個 MPPT 的配置
                                const mpptConfigs = {}; // index -> config
                                
                                bestPlan.forEach(item => {
                                    mpptConfigs[item.mpptIndex] = item;
                                });
                                
                                for (let m = 1; m <= inv.num_mpp_trackers; m++) {
                                    const config = mpptConfigs[m];
                                    
                                    if (config) {
                                        const mpptPanels = config.panels;
                                        const mpptStrings = config.strings;
                                        const mpptPanelsPerString = config.panelsPerString;
                                        
                                        totalAssigned += mpptPanels;
                                        remainingPanels -= mpptPanels;
                                        
                                        // 計算設計電壓和電流
                                        const V_design_stc = mpptPanelsPerString * V_mp_stc;
                                        const V_design_min_temp = mpptPanelsPerString * V_mp_max_temp;
                                        const V_design_max_temp = mpptPanelsPerString * V_oc_min_temp;
                                        const Voc_0C = mpptPanelsPerString * V_oc_min_temp;
                                        const Voc_75C = mpptPanelsPerString * (mod.v_oc * (1 + coef_Voc * (T_max - T_stc)));
                                        const I_total = mpptStrings * I_string;
                                        
                                        // 驗證電壓範圍
                                        const operatingVoltage = inv.rated_input_voltage_v || mppt_min;
                                        const isVLow = V_design_min_temp < operatingVoltage;
                                        const isVInRange = V_design_min_temp >= mppt_min && V_design_min_temp <= mppt_max;
                                        const isVHigh_MPPT = V_design_stc > mppt_max;
                                        const isVHigh_System = V_design_max_temp > inv.max_input_voltage_v;
                                        const isVHigh = isVHigh_MPPT || isVHigh_System;
                                        
                                        // 狀態判斷
                                        let statusClass = 'status-ok', statusText = 'OK';
                                        if (isVLow) {
                                            statusClass = 'status-err';
                                            statusText = '電壓過低';
                                        } else if (isVHigh) {
                                            statusClass = 'status-warn';
                                            statusText = isVHigh_System ? '超過系統耐壓' : '電壓過高(削波)';
                                        } else if (isVInRange) {
                                            statusClass = 'status-ok';
                                            statusText = 'OK';
                                        }
                                        
                                        // 屋頂分配
                                        const roof = roofs[(m - 1) % roofCount];
                                        const roofAssign = (roof && roof.name) ? String(roof.name) : `屋頂 ${((m-1) % roofCount) + 1}`;
                                        
                                        // 顯示串列資訊
                                        const stringDisplay = mpptStrings > 1
                                            ? `${mpptStrings}串 x ${mpptPanelsPerString}片 (${Array(mpptStrings).fill(mpptPanelsPerString).join('+')})`
                                            : `1串 x ${mpptPanelsPerString}片`;
                                        
                                        mpptHtml += `
                                            <div class="flex items-center py-2 border-b border-gray-100 last:border-0 hover:bg-slate-50 transition-colors">
                                                <div class="font-bold text-slate-700 w-16 flex-shrink-0 text-center bg-slate-100 rounded py-1 mr-3">MPPT ${m}</div>
                                                <div class="flex-grow text-xs text-slate-600 font-mono overflow-x-auto whitespace-nowrap">
                                                    ${stringDisplay} | Vmp(STC):${V_design_stc.toFixed(0)}V | Voc(0°C):${Voc_0C.toFixed(0)}V | Voc(75°C):${Voc_75C.toFixed(0)}V | I:${I_total.toFixed(2)}A | ${roofAssign}
                                                </div>
                                                <div class="${statusClass === 'status-ok' ? 'bg-green-600 text-white' : (statusClass === 'status-warn' ? 'bg-yellow-100 text-yellow-800' : 'bg-red-100 text-red-800')} text-xs font-bold px-3 py-1 rounded-full shadow-sm ml-3 flex-shrink-0">${statusText}</div>
                                            </div>`;
                                        
                                        planDetails.push(`MPPT${m}: ${stringDisplay} (V_STC:${V_design_stc.toFixed(0)}V, V_75°C:${V_design_min_temp.toFixed(0)}V, V_0°C:${V_design_max_temp.toFixed(0)}V, I:${I_total.toFixed(2)}A, ${roofAssign})`);
                                    } else {
                                        // 未使用的MPPT
                                        mpptHtml += `
                                            <div class="flex items-center py-2 border-b border-gray-100 last:border-0 opacity-50">
                                                <div class="font-bold text-slate-700 w-16 flex-shrink-0 text-center bg-slate-100 rounded py-1 mr-3">MPPT ${m}</div>
                                                <div class="flex-grow text-xs text-gray-400 font-mono">未使用</div>
                                                <div class="bg-gray-100 text-gray-500 text-xs font-bold px-3 py-1 rounded-full shadow-sm ml-3 flex-shrink-0">跳過</div>
                                            </div>`;
                                    }
                                }
                            } else {
                                // 如果沒有找到任何有效方案，標記所有MPPT為未使用
                                for (let m = 1; m <= inv.num_mpp_trackers; m++) {
                                    mpptHtml += `
                                        <div class="flex items-center py-2 border-b border-gray-100 last:border-0 opacity-50">
                                            <div class="font-bold text-slate-700 w-16 flex-shrink-0 text-center bg-slate-100 rounded py-1 mr-3">MPPT ${m}</div>
                                            <div class="flex-grow text-xs text-gray-400 font-mono">未使用 (無法找到有效的分配方案)</div>
                                            <div class="bg-gray-100 text-gray-500 text-xs font-bold px-3 py-1 rounded-full shadow-sm ml-3 flex-shrink-0">跳過</div>
                                        </div>`;
                                }
                            }
                        } // 閉合 else 分支（容量檢查）

                        // 檢查是否有未分配的片數
                        const unassigned = targetPanelsTotal - totalAssigned;
                        const hasUnassigned = unassigned > 0;
                        
                        // 如果有殘餘片數，顯示警告並提示更改逆變器
                        if (hasUnassigned) {
                            mpptHtml += `
                                <div class="mt-2 p-3 bg-red-50 border-2 border-red-300 rounded-lg text-sm text-red-800">
                                    <div class="flex items-start">
                                        <i class="fa-solid fa-exclamation-circle mr-2 mt-0.5 text-red-600"></i>
                                        <div>
                                            <div class="font-bold mb-1">無法配置所有片數</div>
                                            <div>有 <strong class="text-red-700">${unassigned} 片</strong> 模組無法分配到此逆變器配置</div>
                                            <div class="mt-2 text-xs text-red-700">
                                                <strong>建議：</strong>
                                                <ul class="list-disc list-inside mt-1 space-y-1">
                                                    <li>更改逆變器型號或數量</li>
                                                    <li>調整 DC/AC 超配比</li>
                                                    <li>檢查串列限制是否符合要求</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>`;
                        }

                        // Store for PDF
                        App.reportData.planning.push({
                            model: inv.model_name,
                            ratio: `${(ratio*100).toFixed(0)}%`,
                            totalPanels: targetPanelsTotal,
                            assignedPanels: totalAssigned,
                            details: planDetails,
                            // Add detailed stats for report
                            stats: {
                                mpptRange: `${mppt_min}~${mppt_max}V`,
                                limitStr: `${limit_str_min} <= N <= ${limit_str_max_mppt_final} 片/串 (Nmin(75°C):${Nmin}片, Nmax(Safety):${Nmax}片)`,
                                maxCurrent: `MPPT最大電流: ${maxCurrentPerMPPT !== null && maxCurrentPerMPPT !== 999 ? maxCurrentPerMPPT + 'A' : (inv.max_input_current_per_mppt_a ? '資料異常' : '資料缺失')} | 模組最大電流: ${I_string.toFixed(2)}A | 可並聯最多 ${finalMaxParallelStrings} 串 (MPPT×1.05)`,
                                tempCoef: `Voc=${(coef_Voc*100).toFixed(2)}%/°C, Vmp=${(coef_Vmp*100).toFixed(2)}%/°C`,
                                singleModVoc: `${(mod.v_oc * (1 + coef_Voc * (T_max - T_stc))).toFixed(2)}V@75°C / ${(mod.v_oc * (1 + coef_Voc * (T_min - T_stc))).toFixed(2)}V@0°C`,
                                singleModVmp: `${((mod.v_mp || mod.v_oc * 0.85) * (1 + coef_Vmp * (T_max - T_stc))).toFixed(2)}V`
                            }
                        });

                        html += `
                            <div class="plan-card ${hasUnassigned ? 'border-2 border-red-300' : ''}">
                                <div class="plan-header ${hasUnassigned ? 'bg-red-50' : ''}">
                                    <div><i class="fa-solid fa-server mr-2 ${hasUnassigned ? 'text-red-600' : 'text-blue-600'}"></i>${inv.model_name} <span class="text-xs font-normal text-gray-500 ml-2">x${qty}台</span></div>
                                    <div class="text-xs ${hasUnassigned ? 'bg-red-100 text-red-800' : 'bg-blue-100 text-blue-800'} px-2 py-1 rounded">DC/AC: ${(ratio*100).toFixed(0)}%</div>
                                    ${hasUnassigned ? `<div class="text-xs bg-red-200 text-red-900 px-2 py-1 rounded font-bold"><i class="fa-solid fa-exclamation-triangle mr-1"></i>未分配: ${unassigned} 片</div>` : ''}
                                </div>
                                <div class="plan-body">
                                    <div class="text-xs text-gray-500 mb-2 flex gap-4 flex-wrap">
                                        <span><i class="fa-solid fa-layer-group mr-1"></i>總片數: ${targetPanelsTotal} <span class="${hasUnassigned ? 'text-red-600 font-bold' : ''}">(已分配: ${totalAssigned} 片)</span></span>
                                        <span><i class="fa-solid fa-ruler-horizontal mr-1"></i>MPPT範圍: ${isNaN(mppt_min) || isNaN(mppt_max) ? 'N/A' : `${mppt_min}~${mppt_max}V`}</span>
                                        <span><i class="fa-solid fa-bolt mr-1"></i>串列限制: ${limit_str_min} <= N <= ${limit_str_max_mppt_final} 片/串 (Nmin(75°C):${Nmin}片, Nmax(Safety):${Nmax}片)</span>
                                        <span><i class="fa-solid fa-plug mr-1"></i>MPPT最大電流: ${maxCurrentPerMPPT !== null && maxCurrentPerMPPT !== 999 ? maxCurrentPerMPPT + 'A' : (inv.max_input_current_per_mppt_a ? '資料異常，請檢查' : '資料缺失')} | 模組最大電流: ${I_string.toFixed(2)}A | 可並聯最多 ${finalMaxParallelStrings} 串 ${maxCurrentPerMPPT !== null && maxCurrentPerMPPT !== 999 ? `(${(maxCurrentPerMPPT*1.05).toFixed(2)}A(=MPPT×1.05) ÷ ${I_string.toFixed(2)}A)` : '(請檢查逆變器規格)'}</span>
                                        <span><i class="fa-solid fa-thermometer-half mr-1"></i>溫度係數: Voc=${(coef_Voc*100).toFixed(2)}%/°C, Vmp=${(coef_Vmp*100).toFixed(2)}%/°C</span>
                                        <span><i class="fa-solid fa-bolt mr-1"></i>單片模組Voc: ${(mod.v_oc * (1 + coef_Voc * (T_max - T_stc))).toFixed(2)}V@75°C / ${(mod.v_oc * (1 + coef_Voc * (T_min - T_stc))).toFixed(2)}V@0°C</span>
                                        <span><i class="fa-solid fa-bolt mr-1"></i>單片模組Vmp(75°C): ${((mod.v_mp || mod.v_oc * 0.85) * (1 + coef_Vmp * (T_max - T_stc))).toFixed(2)}V</span>
                                    </div>
                                    ${mpptHtml}
                                </div>
                            </div>
                        `;
                    });
                    
                    resDiv.innerHTML = html || `<div class="text-center text-gray-400 p-8 border-2 border-dashed rounded-lg col-span-full">請配置有效的逆變器...</div>`;
                }
            },

            actions: {
                saveState: () => {
                    const state = {
                        v: document.getElementById('gridVoltage').value,
                        panels: document.getElementById('plannedPanels').value, // 保留相容舊版（總片數）
                        roofs: Array.isArray(App.roofs) ? App.roofs : [],
                        mva: document.getElementById('sourceMVA').value
                    };
                    localStorage.setItem(CONFIG.storageKey, JSON.stringify(state));
                    const btn = document.querySelector('button[onclick="App.actions.saveState()"]');
                    if(btn) {
                        const orig = btn.innerHTML;
                        btn.innerHTML = '<i class="fa-solid fa-check"></i> 已儲存';
                        setTimeout(() => btn.innerHTML = orig, 1500);
                    }
                },
                loadState: () => {
                    const raw = localStorage.getItem(CONFIG.storageKey);
                    if(!raw) return;
                    try {
                        const s = JSON.parse(raw);
                        if(s.v) document.getElementById('gridVoltage').value = s.v;
                        if(s.mva) document.getElementById('sourceMVA').value = s.mva;
                        
                        // 屋頂清單（新版本）：若存在 roofs 則以 roofs 為準；否則用舊版 panels 轉成單一屋頂
                        if (Array.isArray(s.roofs) && s.roofs.length > 0) {
                            App.roofs = s.roofs.map((r, idx) => ({
                                id: r?.id ?? (Date.now() + idx),
                                name: (r?.name ? String(r.name) : `屋頂 ${idx + 1}`),
                                panels: parseInt(r?.panels || 0) || 0
                            }));
                        } else if (typeof s.panels !== 'undefined') {
                            App.roofs = [{ id: Date.now(), name: '屋頂 1', panels: parseInt(s.panels || 0) || 0 }];
                        }
                        // 重新渲染並同步總片數
                        App.ui.renderRoofs();
                        App.ui.syncPlannedPanelsFromRoofs();
                        // 觸發容量計算
                        setTimeout(() => App.calc.runDebounced(), 500);
                    } catch(e) { console.error("Load State Error", e); }
                },
                exportPDF: async () => {
                    const { jsPDF } = window.jspdf;
                    if(!App.reportData.planning.length && !App.reportData.vd.length) { 
                        alert("請先完成規劃或計算"); 
                        return; 
                    }

                    // 1. Setup Staging Area
                    let staging = document.getElementById('pdf-staging-area');
                    if (!staging) {
                        staging = document.createElement('div');
                        staging.id = 'pdf-staging-area';
                        document.body.appendChild(staging);
                    }
                    staging.innerHTML = ''; // Clear

                    // 2. Prepare Data & Utils
                    const d = new Date();
                    const dateStr = `${d.getFullYear()}/${String(d.getMonth()+1).padStart(2,'0')}/${String(d.getDate()).padStart(2,'0')}`;
                    
                    const sysVoltage = document.getElementById('gridVoltage')?.value || 'N/A';
                    const sysPanels = document.getElementById('plannedPanels')?.value || '0';
                    const modIdx = document.getElementById('activeModuleSelect')?.value;
                    let modInfo = 'N/A';
                    if (modIdx !== "" && App.cache.modules[modIdx]) {
                        const m = App.cache.modules[modIdx];
                        modInfo = `${m.manufacturer} ${m.model_number} (${m.p_max}W)`;
                    }

                    // 3. Build Flat Source Elements
                    // Instead of building one big HTML, we build "Blocks"
                    const blocks = [];

                    // System Info Block
                    blocks.push({
                        type: 'section-title',
                        html: `系統基本資訊 (System Information)`
                    });
                    
                    let infoTableHtml = `
                        <table class="report-table" style="border-top:none;">
                            <tr><th style="width:35%;">項目 Item</th><th>數值 Value</th></tr>
                            <tr><td>系統電壓 System Voltage</td><td>${sysVoltage} V</td></tr>
                            <tr><td>規劃片數 Planned Panels</td><td>${sysPanels} 片</td></tr>
                            <tr><td>選用模組 Selected Module</td><td>${modInfo}</td></tr>
                            ${App.reportData.totalVd ? `<tr><td>總電壓降 Total Voltage Drop</td><td style="font-weight:bold; color:#1e40af;">${App.reportData.totalVd}</td></tr>` : ''}
                            ${App.reportData.scFinal ? `<tr><td>短路電流 Short Circuit Current</td><td style="font-weight:bold; color:#b91c1c;">${App.reportData.scFinal}</td></tr>` : ''}
                        </table>
                    `;
                    blocks.push({ type: 'item', html: infoTableHtml });

                    // Section 1: Planning
                    if (App.reportData.planning.length > 0) {
                        blocks.push({ type: 'section-title', html: '1. 逆變器串列規劃 (Inverter String Sizing)' });
                        App.reportData.planning.forEach((p, idx) => {
                             // Parse details or use structured data if available
                             // If p.stats exists, we use the new rich layout
                             const stats = p.stats || {};
                             
                             // Helper to parse detail string if needed, or we can just render it simply if we don't want to over-engineer regex
                             // detail string format: "MPPT 1 \t 1串 x 20片 \t | Vmp: ... | Voc: ... | I: ... \t Status"
                             // We will format it as a table row
                             
                             let rowsHtml = '';
                             p.details.forEach(d => {
                                 // Split by tab
                                 // Format: Name \t Config \t Details \t Status
                                 let parts = d.split('\t');
                                 let mpptName = parts[0] ? parts[0].trim() : '';
                                 let config = parts[1] ? parts[1].trim() : '';
                                 let tech = parts[2] ? parts[2].trim() : '';
                                 let status = parts[3] ? parts[3].trim() : 'OK';
                                 
                                // Determine badge color based on status
                                let badgeHtml = '';
                                if (status === 'OK') {
                                    badgeHtml = `<span style="display: inline-block; text-align: center; width: 24px; height: 14px; line-height: 14px; border: 1px solid #22c55e; color: #16a34a; background: #f0fdf4; border-radius: 4px; font-size: 8px; font-weight: bold; vertical-align: middle;">OK</span>`;
                                } else if (status === '跳過' || status === '未使用') {
                                    badgeHtml = `<span style="font-size:8px; color:#94a3b8; vertical-align: middle;">跳過</span>`;
                                } else if (status.includes('過高') || status.includes('過載') || status.includes('ERR')) {
                                    badgeHtml = `<span style="display: inline-block; text-align: center; width: 28px; height: 14px; line-height: 14px; border: 1px solid #ef4444; color: #b91c1c; background: #fef2f2; border-radius: 4px; font-size: 8px; font-weight: bold; vertical-align: middle;">ERR</span>`;
                                } else if (status.includes('過低') || status.includes('WARN')) {
                                    badgeHtml = `<span style="display: inline-block; text-align: center; width: 32px; height: 14px; line-height: 14px; border: 1px solid #eab308; color: #a16207; background: #fefce8; border-radius: 4px; font-size: 8px; font-weight: bold; vertical-align: middle;">WARN</span>`;
                                } else {
                                    badgeHtml = `<span style="font-size:8px; color:#64748b; vertical-align: middle;">${status}</span>`;
                                }
                                 
                                 let isUnused = config.includes('未使用');
                                 
                                if (isUnused) {
                                    rowsHtml += `
                                       <div style="padding: 4px 0; border-bottom: 1px solid #f8fafc; overflow: hidden; line-height: 14px;">
                                           <div style="float: right; width: 40px; text-align: right;">${badgeHtml}</div>
                                           <div style="float: left; width: 50px; font-weight:bold; color:#cbd5e1; font-size:9px;">${mpptName}</div>
                                           <div style="margin-left: 50px; margin-right: 40px; color:#cbd5e1; font-size:9px;">未使用</div>
                                       </div>`;
                                } else {
                                   rowsHtml += `
                                      <div style="padding: 4px 0; border-bottom: 1px solid #f1f5f9; overflow: hidden; line-height: 14px;">
                                          <div style="float: right; width: 40px; text-align: right;">${badgeHtml}</div>
                                          <div style="float: left; width: 50px; font-weight:bold; color:#475569; font-size:9px; white-space: nowrap;">${mpptName}</div>
                                          <div style="float: left; width: 70px; font-weight:bold; color:#0f172a; font-size:9px; white-space: nowrap;">${config}</div>
                                          <div style="margin-left: 125px; margin-right: 45px; font-family:'Consolas', monospace; font-size:8px; color:#64748b; white-space: nowrap !important; overflow: hidden; text-overflow: ellipsis; line-height: 14px;">
                                              ${tech.replace(/Vmp:/g, '<span class="text-blue-600 font-bold">Vmp:</span>').replace(/Voc:/g, '<span class="text-slate-500 font-bold">Voc:</span>').replace(/I:/g, '<span class="text-amber-600 font-bold">I:</span>')}
                                          </div>
                                      </div>`;
                                }
                             });

                             let itemHtml = `
                                <div class="report-item" style="border: 1px solid #e2e8f0; border-radius: 6px; padding: 15px; margin-bottom: 15px; background: #fff; page-break-inside: avoid;">
                                    <!-- Header -->
                                    <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #e2e8f0; padding-bottom: 10px; margin-bottom: 12px; background: #f8fafc; margin: -15px -15px 12px -15px; padding: 10px 15px; border-radius: 6px 6px 0 0;">
                                        <div style="font-weight: bold; color: #0f172a; font-size: 14px; display: flex; align-items: center;">
                                            <i class="fa-solid fa-server text-blue-600 mr-2"></i>
                                            ${p.model} <span style="font-weight:normal; color:#64748b; font-size:12px; margin-left:5px;">x1台</span>
                                        </div>
                                        <div style="font-size: 11px; background: #eff6ff; color: #1e40af; padding: 4px 8px; border-radius: 4px; font-weight: 600; border: 1px solid #dbeafe; display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                                            DC/AC: ${p.ratio}
                                        </div>
                                    </div>

                                    <!-- Summary Info (Icon based) -->
                                    <div style="font-size: 10px; color: #475569; margin-bottom: 15px; line-height: 1.8;">
                                        <div style="display:flex; flex-wrap:wrap; gap:12px;">
                                            <div><i class="fa-solid fa-layer-group text-slate-400 mr-1"></i>總片數: ${p.totalPanels} (已分配: ${p.assignedPanels} 片)</div>
                                            <div><i class="fa-solid fa-ruler-horizontal text-slate-400 mr-1"></i>MPPT範圍: ${stats.mpptRange || 'N/A'}</div>
                                        </div>
                                        <div><i class="fa-solid fa-bolt text-slate-400 mr-1"></i>串列限制: ${stats.limitStr || 'N/A'}</div>
                                        <div><i class="fa-solid fa-plug text-slate-400 mr-1"></i>${stats.maxCurrent || 'N/A'}</div>
                                        <div style="display:flex; flex-wrap:wrap; gap:12px;">
                                            <div><i class="fa-solid fa-thermometer-half text-slate-400 mr-1"></i>溫度係數: ${stats.tempCoef || 'N/A'}</div>
                                        </div>
                                        <div style="display:flex; flex-wrap:wrap; gap:12px;">
                                            <div><i class="fa-solid fa-solar-panel text-slate-400 mr-1"></i>單片Voc: ${stats.singleModVoc || 'N/A'}</div>
                                            <div><i class="fa-solid fa-solar-panel text-slate-400 mr-1"></i>單片Vmp(75°C): ${stats.singleModVmp || 'N/A'}</div>
                                        </div>
                                    </div>

                                    <!-- MPPT Details Table -->
                                    <div style="border-top: 1px solid #f1f5f9;">
                                        ${rowsHtml}
                                    </div>
                                </div>`;
                            blocks.push({ type: 'item', html: itemHtml });
                        });
                    }

                    // Section 2: VD
                    if (App.reportData.vd && App.reportData.vd.length > 0) {
                        blocks.push({ type: 'section-title', html: '2. 電壓降計算 (Voltage Drop Calculation)' });
                        App.reportData.vd.forEach(item => {
                            let itemHtml = `
                            <div class="report-item">
                                <div style="font-weight:bold; color:#1e40af; margin-bottom:4px; font-size:14px;">
                                    <i class="fa-solid fa-calculator" style="margin-right:6px; font-size:12px;"></i>${item.title || '計算項目'}
                                </div>
                                ${item.params ? `<div style="font-size:0.9em; color:#475569; margin-bottom:6px;">${item.params}</div>` : ''}
                                ${item.formula ? `<div class="report-formula">${item.formula}</div>` : ''}
                                ${item.process ? `<div class="report-process">= ${item.process}</div>` : ''}
                                ${item.process2 ? `<div class="report-process">= ${item.process2}</div>` : ''}
                                ${item.process3 ? `<div class="report-process">= ${item.process3}</div>` : ''}
                                ${item.result ? `<div class="report-result">= ${item.result}</div>` : ''}
                            </div>`;
                            blocks.push({ type: 'item', html: itemHtml });
                        });
                        
                        if (App.reportData.totalVd) {
                             blocks.push({ type: 'item', html: `
                                <div class="report-summary-box">
                                    <div style="font-size:14px; opacity:0.95;">系統總電壓降 (Total System Voltage Drop)</div>
                                    <div class="report-summary-value" style="color:#1e40af;">${App.reportData.totalVd}</div>
                                </div>` 
                            });
                        }
                    }

                    // Section 3: SC
                    if (App.reportData.sc && App.reportData.sc.length > 0) {
                        const secNum = (App.reportData.planning.length > 0 && App.reportData.vd.length > 0) ? '3' : '2';
                        blocks.push({ type: 'section-title', html: `${secNum}. 短路電流計算 (Short Circuit Current)` });
                        App.reportData.sc.forEach(item => {
                             let itemHtml = `
                            <div class="report-item">
                                <div style="font-weight:bold; color:#b91c1c; margin-bottom:4px; font-size:14px;">
                                    <i class="fa-solid fa-bolt" style="margin-right:6px; font-size:12px;"></i>${item.title || '計算項目'}
                                </div>
                                ${item.params ? `<div style="font-size:0.9em; color:#475569; margin-bottom:6px;">${item.params}</div>` : ''}
                                ${item.formula ? `<div class="report-formula" style="color:#b91c1c;">${item.formula}</div>` : ''}
                                ${item.process ? `<div class="report-process">= ${item.process}</div>` : ''}
                                ${item.process2 ? `<div class="report-process">= ${item.process2}</div>` : ''}
                                ${item.process3 ? `<div class="report-process">= ${item.process3}</div>` : ''}
                                ${item.result ? `<div class="report-result">= ${item.result}</div>` : ''}
                            </div>`;
                            blocks.push({ type: 'item', html: itemHtml });
                        });
                        
                        if (App.reportData.scFinal) {
                             blocks.push({ type: 'item', html: `
                                <div class="report-summary-box">
                                    <div style="font-size:14px; opacity:0.9;">系統短路電流 (System Short Circuit Current)</div>
                                    <div class="report-summary-value" style="color:#b91c1c;">${App.reportData.scFinal}</div>
                                    <div style="font-size:11px; opacity:0.8; margin-top:5px;">IEC 60909 Standard</div>
                                </div>` 
                            });
                        }
                    }

                    // 4. Pagination Logic
                    const pdfPages = [];
                    const mmToPx = 3.78; // Approx for 96 DPI. html2canvas might use distinct.
                    // We will rely on offsetHeight.
                    // A4 height = 297mm. Body height = 237mm (approx 895px).
                    
                    // Create a dummy page to measure content height correctly
                    const measurePage = document.createElement('div');
                    measurePage.className = 'pdf-measure-page'; // Changed class to avoid selection
                    measurePage.style.position = 'absolute';
                    measurePage.style.visibility = 'hidden';
                    staging.appendChild(measurePage);
                    
                    const measureBody = document.createElement('div');
                    measureBody.className = 'pdf-body-layer';
                    measurePage.appendChild(measureBody);

                    let currentPage = null;
                    let currentBody = null;
                    let currentHeight = 0;
                    const maxBodyHeightPx = 890; // Safe limit in px (237mm ~ 895px)

                    const createNewPage = (pageNum) => {
                        const p = document.createElement('div');
                        p.className = 'pdf-page';
                        
                        // Header
                        const h = document.createElement('div');
                        h.className = 'pdf-header-layer';
                        h.innerHTML = `
                            <div class="report-doc-title">太陽光電系統規劃報告書</div>
                            <div class="report-doc-subtitle">Solar Photovoltaic System Planning Report</div>
                        `;
                        p.appendChild(h);

                        // Footer
                        const f = document.createElement('div');
                        f.className = 'pdf-footer-layer';
                        f.innerHTML = `
                            <div>Generated by SolarPlanning Tool</div>
                            <div>第 ${pageNum} 頁</div>
                        `;
                        p.appendChild(f);

                        // Body Container
                        const b = document.createElement('div');
                        b.className = 'pdf-body-layer';
                        p.appendChild(b);

                        staging.appendChild(p);
                        return { page: p, body: b };
                    };

                    // Init first page
                    let pageIdx = 1;
                    let newP = createNewPage(pageIdx);
                    currentPage = newP.page;
                    currentBody = newP.body;

                    // Helper to create element from HTML
                    const elFromHtml = (html) => {
                        const d = document.createElement('div');
                        d.innerHTML = html;
                        return d.firstElementChild || d;
                    };

                    // Wait for fonts
                    await document.fonts.ready;

                    // Fill Pages
                    for (const block of blocks) {
                        let el;
                        if (block.type === 'section-title') {
                            el = document.createElement('div');
                            el.className = 'report-group-title';
                            el.innerHTML = block.html;
                        } else {
                            // Item
                            el = document.createElement('div');
                            el.innerHTML = block.html; 
                        }

                        // Append to test height
                        measureBody.appendChild(el.cloneNode(true));
                        
                        // Measure height including margins
                        const testEl = measureBody.lastElementChild;
                        const style = window.getComputedStyle(testEl);
                        const marginTop = parseFloat(style.marginTop) || 0;
                        const marginBottom = parseFloat(style.marginBottom) || 0;
                        const itemHeight = testEl.offsetHeight + marginTop + marginBottom;
                        
                        // Check fit
                        if (currentHeight + itemHeight > maxBodyHeightPx) {
                            // New Page
                            pageIdx++;
                            newP = createNewPage(pageIdx);
                            currentPage = newP.page;
                            currentBody = newP.body;
                            currentHeight = 0;
                        }
                        
                        // Add to real page
                         if (typeof block.html === 'string' && block.type === 'item') {
                             currentBody.insertAdjacentHTML('beforeend', block.html);
                         } else {
                             currentBody.appendChild(el);
                         }
                         
                         // Update height
                         currentHeight += itemHeight;
                         measureBody.innerHTML = ''; // Clear measure
                    }

                    // Remove the measurement page
                    if (measurePage.parentNode) measurePage.parentNode.removeChild(measurePage);

                    // 5. Render
                    const pdf = new jsPDF('p', 'mm', 'a4');
                    // Only select actual pages, strictly excluding the measure page if it somehow remained
                    const pages = staging.querySelectorAll('.pdf-page');
                    
                    for (let i = 0; i < pages.length; i++) {
                        if (i > 0) pdf.addPage();
                        
                        const canvas = await html2canvas(pages[i], {
                            scale: 2,
                            useCORS: true,
                            logging: false,
                            backgroundColor: '#ffffff'
                        });
                        
                        const imgData = canvas.toDataURL('image/jpeg', 1.0);
                        pdf.addImage(imgData, 'JPEG', 0, 0, 210, 297);
                    }
                    
                    pdf.save(`Solar_Planning_Report_${Date.now()}.pdf`);
                    
                    // Cleanup? staging.remove(); // Optional
                }
            }
        };

        document.addEventListener('DOMContentLoaded', App.auth.init);
    </script>
</body>
</html>


